/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export type paths = {
  "/health": {
    /**
     * Health
     * @description Get health status of the server.
     *
     * Returns:
     *     String representing the health status of the server.
     */
    get: operations["health_health_get"];
  };
  "/api/v1/login": {
    /**
     * Token
     * @description OAuth2 token endpoint.
     *
     * Args:
     *     request: The request object.
     *     response: The response object.
     *     auth_form_data: The OAuth 2.0 authentication form data.
     *
     * Returns:
     *     An access token or a redirect response.
     *
     * Raises:
     *     ValueError: If the grant type is invalid.
     */
    post: operations["token_api_v1_login_post"];
  };
  "/api/v1/logout": {
    /**
     * Logout
     * @description Logs out the user.
     *
     * Args:
     *     response: The response object.
     */
    get: operations["logout_api_v1_logout_get"];
  };
  "/api/v1/device_authorization": {
    /**
     * Device Authorization
     * @description OAuth2 device authorization endpoint.
     *
     * This endpoint implements the OAuth2 device authorization grant flow as
     * defined in https://tools.ietf.org/html/rfc8628. It is called to initiate
     * the device authorization flow by requesting a device and user code for a
     * given client ID.
     *
     * For a new client ID, a new OAuth device is created, stored in the DB and
     * returned to the client along with a pair of newly generated device and user
     * codes. If a device for the given client ID already exists, the existing
     * DB entry is reused and new device and user codes are generated.
     *
     * Args:
     *     request: The request object.
     *     client_id: The client ID.
     *
     * Returns:
     *     The device authorization response.
     */
    post: operations["device_authorization_api_v1_device_authorization_post"];
  };
  "/api/v1/api_token": {
    /**
     * Api Token
     * @description Get a workload API token for the current user.
     *
     * Args:
     *     pipeline_id: The ID of the pipeline to get the API token for.
     *     schedule_id: The ID of the schedule to get the API token for.
     *     expires_minutes: The number of minutes for which the API token should
     *         be valid. If not provided, the API token will be valid indefinitely.
     *     auth_context: The authentication context.
     *
     * Returns:
     *     The API token.
     *
     * Raises:
     *     HTTPException: If the user is not authenticated.
     */
    get: operations["api_token_api_v1_api_token_get"];
  };
  "/api/v1/devices": {
    /**
     * List Authorized Devices
     * @description Gets a page of OAuth2 authorized devices belonging to the current user.
     *
     * Args:
     *     filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *     auth_context: The current auth context.
     *
     * Returns:
     *     Page of OAuth2 authorized device objects.
     */
    get: operations["list_authorized_devices_api_v1_devices_get"];
  };
  "/api/v1/devices/{device_id}": {
    /**
     * Get Authorization Device
     * @description Gets a specific OAuth2 authorized device using its unique ID.
     *
     * Args:
     *     device_id: The ID of the OAuth2 authorized device to get.
     *     user_code: The user code of the OAuth2 authorized device to get. Needs
     *         to be specified with devices that have not been verified yet.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *     auth_context: The current auth context.
     *
     * Returns:
     *     A specific OAuth2 authorized device object.
     *
     * Raises:
     *     KeyError: If the device with the given ID does not exist, does not
     *         belong to the current user or could not be verified using the
     *         given user code.
     */
    get: operations["get_authorization_device_api_v1_devices__device_id__get"];
    /**
     * Update Authorized Device
     * @description Updates a specific OAuth2 authorized device using its unique ID.
     *
     * Args:
     *     device_id: The ID of the OAuth2 authorized device to update.
     *     update: The model containing the attributes to update.
     *     auth_context: The current auth context.
     *
     * Returns:
     *     The updated OAuth2 authorized device object.
     *
     * Raises:
     *     KeyError: If the device with the given ID does not exist or does not
     *         belong to the current user.
     */
    put: operations["update_authorized_device_api_v1_devices__device_id__put"];
    /**
     * Delete Authorized Device
     * @description Deletes a specific OAuth2 authorized device using its unique ID.
     *
     * Args:
     *     device_id: The ID of the OAuth2 authorized device to delete.
     *     auth_context: The current auth context.
     *
     * Raises:
     *     KeyError: If the device with the given ID does not exist or does not
     *         belong to the current user.
     */
    delete: operations["delete_authorized_device_api_v1_devices__device_id__delete"];
  };
  "/api/v1/devices/{device_id}/verify": {
    /**
     * Verify Authorized Device
     * @description Verifies a specific OAuth2 authorized device using its unique ID.
     *
     * This endpoint implements the OAuth2 device authorization grant flow as
     * defined in https://tools.ietf.org/html/rfc8628. It is called to verify
     * the user code for a given device ID.
     *
     * If the user code is valid, the device is marked as verified and associated
     * with the user that authorized the device. This association is required to
     * be able to issue access tokens or revoke the device later on.
     *
     * Args:
     *     device_id: The ID of the OAuth2 authorized device to update.
     *     request: The model containing the verification request.
     *     auth_context: The current auth context.
     *
     * Returns:
     *     The updated OAuth2 authorized device object.
     *
     * Raises:
     *     ValueError: If the device verification request fails.
     */
    put: operations["verify_authorized_device_api_v1_devices__device_id__verify_put"];
  };
  "/api/v1/pipelines": {
    /**
     * List Pipelines
     * @description Gets a list of pipelines.
     *
     * Args:
     *     pipeline_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     List of pipeline objects.
     */
    get: operations["list_pipelines_api_v1_pipelines_get"];
  };
  "/api/v1/pipelines/{pipeline_id}": {
    /**
     * Get Pipeline
     * @description Gets a specific pipeline using its unique id.
     *
     * Args:
     *     pipeline_id: ID of the pipeline to get.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     A specific pipeline object.
     */
    get: operations["get_pipeline_api_v1_pipelines__pipeline_id__get"];
    /**
     * Update Pipeline
     * @description Updates the attribute on a specific pipeline using its unique id.
     *
     * Args:
     *     pipeline_id: ID of the pipeline to get.
     *     pipeline_update: the model containing the attributes to update.
     *
     * Returns:
     *     The updated pipeline object.
     */
    put: operations["update_pipeline_api_v1_pipelines__pipeline_id__put"];
    /**
     * Delete Pipeline
     * @description Deletes a specific pipeline.
     *
     * Args:
     *     pipeline_id: ID of the pipeline to delete.
     */
    delete: operations["delete_pipeline_api_v1_pipelines__pipeline_id__delete"];
  };
  "/api/v1/pipelines/{pipeline_id}/runs": {
    /**
     * List Pipeline Runs
     * @description Get pipeline runs according to query filters.
     *
     * Args:
     *     pipeline_run_filter_model: Filter model used for pagination, sorting,
     *         filtering
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The pipeline runs according to query filters.
     */
    get: operations["list_pipeline_runs_api_v1_pipelines__pipeline_id__runs_get"];
  };
  "/api/v1/pipelines/{pipeline_id}/pipeline-spec": {
    /**
     * Get Pipeline Spec
     * @description Gets the spec of a specific pipeline using its unique id.
     *
     * Args:
     *     pipeline_id: ID of the pipeline to get.
     *
     * Returns:
     *     The spec of the pipeline.
     */
    get: operations["get_pipeline_spec_api_v1_pipelines__pipeline_id__pipeline_spec_get"];
  };
  "/api/v1/workspaces": {
    /**
     * List Workspaces
     * @description Lists all workspaces in the organization.
     *
     * Args:
     *     workspace_filter_model: Filter model used for pagination, sorting,
     *         filtering,
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     A list of workspaces.
     */
    get: operations["list_workspaces_api_v1_workspaces_get"];
    /**
     * Create Workspace
     * @description Creates a workspace based on the requestBody.
     *
     * # noqa: DAR401
     *
     * Args:
     *     workspace: Workspace to create.
     *
     * Returns:
     *     The created workspace.
     */
    post: operations["create_workspace_api_v1_workspaces_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}": {
    /**
     * Get Workspace
     * @description Get a workspace for given name.
     *
     * # noqa: DAR401
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The requested workspace.
     */
    get: operations["get_workspace_api_v1_workspaces__workspace_name_or_id__get"];
    /**
     * Update Workspace
     * @description Get a workspace for given name.
     *
     * # noqa: DAR401
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace to update.
     *     workspace_update: the workspace to use to update
     *
     * Returns:
     *     The updated workspace.
     */
    put: operations["update_workspace_api_v1_workspaces__workspace_name_or_id__put"];
    /**
     * Delete Workspace
     * @description Deletes a workspace.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     */
    delete: operations["delete_workspace_api_v1_workspaces__workspace_name_or_id__delete"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/stacks": {
    /**
     * List Workspace Stacks
     * @description Get stacks that are part of a specific workspace for the user.
     *
     * # noqa: DAR401
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     stack_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     All stacks part of the specified workspace.
     */
    get: operations["list_workspace_stacks_api_v1_workspaces__workspace_name_or_id__stacks_get"];
    /**
     * Create Stack
     * @description Creates a stack for a particular workspace.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     stack: Stack to register.
     *
     * Returns:
     *     The created stack.
     *
     * Raises:
     *     IllegalOperationError: If the workspace specified in the stack
     *         does not match the current workspace.
     */
    post: operations["create_stack_api_v1_workspaces__workspace_name_or_id__stacks_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/components": {
    /**
     * List Workspace Stack Components
     * @description List stack components that are part of a specific workspace.
     *
     * # noqa: DAR401
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     component_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     All stack components part of the specified workspace.
     */
    get: operations["list_workspace_stack_components_api_v1_workspaces__workspace_name_or_id__components_get"];
    /**
     * Create Stack Component
     * @description Creates a stack component.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     component: Stack component to register.
     *
     * Returns:
     *     The created stack component.
     *
     * Raises:
     *     IllegalOperationError: If the workspace specified in the stack
     *         component does not match the current workspace.
     */
    post: operations["create_stack_component_api_v1_workspaces__workspace_name_or_id__components_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/pipelines": {
    /**
     * List Workspace Pipelines
     * @description Gets pipelines defined for a specific workspace.
     *
     * # noqa: DAR401
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     pipeline_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     All pipelines within the workspace.
     */
    get: operations["list_workspace_pipelines_api_v1_workspaces__workspace_name_or_id__pipelines_get"];
    /**
     * Create Pipeline
     * @description Creates a pipeline.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     pipeline: Pipeline to create.
     *
     * Returns:
     *     The created pipeline.
     *
     * Raises:
     *     IllegalOperationError: If the workspace or user specified in the pipeline
     *         does not match the current workspace or authenticated user.
     */
    post: operations["create_pipeline_api_v1_workspaces__workspace_name_or_id__pipelines_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/pipeline_builds": {
    /**
     * List Workspace Builds
     * @description Gets builds defined for a specific workspace.
     *
     * # noqa: DAR401
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     build_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     All builds within the workspace.
     */
    get: operations["list_workspace_builds_api_v1_workspaces__workspace_name_or_id__pipeline_builds_get"];
    /**
     * Create Build
     * @description Creates a build.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     build: Build to create.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     The created build.
     *
     * Raises:
     *     IllegalOperationError: If the workspace specified in the build
     *         does not match the current workspace.
     */
    post: operations["create_build_api_v1_workspaces__workspace_name_or_id__pipeline_builds_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/pipeline_deployments": {
    /**
     * List Workspace Deployments
     * @description Gets deployments defined for a specific workspace.
     *
     * # noqa: DAR401
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     deployment_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     All deployments within the workspace.
     */
    get: operations["list_workspace_deployments_api_v1_workspaces__workspace_name_or_id__pipeline_deployments_get"];
    /**
     * Create Deployment
     * @description Creates a deployment.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     deployment: Deployment to create.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     The created deployment.
     *
     * Raises:
     *     IllegalOperationError: If the workspace specified in the
     *         deployment does not match the current workspace.
     */
    post: operations["create_deployment_api_v1_workspaces__workspace_name_or_id__pipeline_deployments_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/runs": {
    /**
     * List Runs
     * @description Get pipeline runs according to query filters.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     runs_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The pipeline runs according to query filters.
     */
    get: operations["list_runs_api_v1_workspaces__workspace_name_or_id__runs_get"];
    /**
     * Create Pipeline Run
     * @description Creates a pipeline run.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     pipeline_run: Pipeline run to create.
     *
     * Returns:
     *     The created pipeline run.
     *
     * Raises:
     *     IllegalOperationError: If the workspace specified in the
     *         pipeline run does not match the current workspace.
     */
    post: operations["create_pipeline_run_api_v1_workspaces__workspace_name_or_id__runs_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/schedules": {
    /**
     * Create Schedule
     * @description Creates a schedule.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     schedule: Schedule to create.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     The created schedule.
     *
     * Raises:
     *     IllegalOperationError: If the workspace or user specified in the
     *         schedule does not match the current workspace or authenticated user.
     */
    post: operations["create_schedule_api_v1_workspaces__workspace_name_or_id__schedules_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/runs/get-or-create": {
    /**
     * Get Or Create Pipeline Run
     * @description Get or create a pipeline run.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     pipeline_run: Pipeline run to create.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     The pipeline run and a boolean indicating whether the run was created
     *     or not.
     *
     * Raises:
     *     IllegalOperationError: If the workspace or user specified in the
     *         pipeline run does not match the current workspace or authenticated
     *         user.
     */
    post: operations["get_or_create_pipeline_run_api_v1_workspaces__workspace_name_or_id__runs_get_or_create_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/run-metadata": {
    /**
     * Create Run Metadata
     * @description Creates run metadata.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     run_metadata: The run metadata to create.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     The created run metadata.
     *
     * Raises:
     *     IllegalOperationError: If the workspace or user specified in the run
     *         metadata does not match the current workspace or authenticated user.
     *     RuntimeError: If the resource type is not supported.
     */
    post: operations["create_run_metadata_api_v1_workspaces__workspace_name_or_id__run_metadata_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/secrets": {
    /**
     * Create Secret
     * @description Creates a secret.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     secret: Secret to create.
     *
     * Returns:
     *     The created secret.
     *
     * Raises:
     *     IllegalOperationError: If the workspace specified in the
     *         secret does not match the current workspace.
     */
    post: operations["create_secret_api_v1_workspaces__workspace_name_or_id__secrets_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/code_repositories": {
    /**
     * List Workspace Code Repositories
     * @description Gets code repositories defined for a specific workspace.
     *
     * # noqa: DAR401
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     All code repositories within the workspace.
     */
    get: operations["list_workspace_code_repositories_api_v1_workspaces__workspace_name_or_id__code_repositories_get"];
    /**
     * Create Code Repository
     * @description Creates a code repository.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     code_repository: Code repository to create.
     *
     * Returns:
     *     The created code repository.
     *
     * Raises:
     *     IllegalOperationError: If the workspace or user specified in the
     *         code repository does not match the current workspace or
     *         authenticated user.
     */
    post: operations["create_code_repository_api_v1_workspaces__workspace_name_or_id__code_repositories_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/statistics": {
    /**
     * Get Workspace Statistics
     * @description Gets statistics of a workspace.
     *
     * # noqa: DAR401
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace to get statistics for.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     All pipelines within the workspace.
     */
    get: operations["get_workspace_statistics_api_v1_workspaces__workspace_name_or_id__statistics_get"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/service_connectors": {
    /**
     * List Workspace Service Connectors
     * @description List service connectors that are part of a specific workspace.
     *
     * # noqa: DAR401
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     connector_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     All service connectors part of the specified workspace.
     */
    get: operations["list_workspace_service_connectors_api_v1_workspaces__workspace_name_or_id__service_connectors_get"];
    /**
     * Create Service Connector
     * @description Creates a service connector.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     connector: Service connector to register.
     *
     * Returns:
     *     The created service connector.
     *
     * Raises:
     *     IllegalOperationError: If the workspace or user specified in the service
     *         connector does not match the current workspace or authenticated
     *         user.
     */
    post: operations["create_service_connector_api_v1_workspaces__workspace_name_or_id__service_connectors_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/service_connectors/resources": {
    /**
     * List Service Connector Resources
     * @description List resources that can be accessed by service connectors.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     connector_type: the service connector type identifier to filter by.
     *     resource_type: the resource type identifier to filter by.
     *     resource_id: the resource identifier to filter by.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     The matching list of resources that available service
     *     connectors have access to.
     */
    get: operations["list_service_connector_resources_api_v1_workspaces__workspace_name_or_id__service_connectors_resources_get"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/models": {
    /**
     * Create Model
     * @description Create a new model.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     model: The model to create.
     *
     * Returns:
     *     The created model.
     *
     * Raises:
     *     IllegalOperationError: If the workspace or user specified in the
     *         model does not match the current workspace or authenticated
     *         user.
     */
    post: operations["create_model_api_v1_workspaces__workspace_name_or_id__models_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/models/{model_name_or_id}/model_versions": {
    /**
     * Create Model Version
     * @description Create a new model version.
     *
     * Args:
     *     model_name_or_id: Name or ID of the model.
     *     workspace_name_or_id: Name or ID of the workspace.
     *     model_version: The model version to create.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     The created model version.
     *
     * Raises:
     *     IllegalOperationError: If the workspace specified in the
     *         model version does not match the current workspace.
     */
    post: operations["create_model_version_api_v1_workspaces__workspace_name_or_id__models__model_name_or_id__model_versions_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/model_versions/{model_version_id}/artifacts": {
    /**
     * Create Model Version Artifact Link
     * @description Create a new model version to artifact link.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     model_version_id: ID of the model version.
     *     model_version_artifact_link: The model version to artifact link to create.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     The created model version to artifact link.
     *
     * Raises:
     *     IllegalOperationError: If the workspace or user specified in the
     *         model version does not match the current workspace or authenticated
     *         user.
     */
    post: operations["create_model_version_artifact_link_api_v1_workspaces__workspace_name_or_id__model_versions__model_version_id__artifacts_post"];
  };
  "/api/v1/workspaces/{workspace_name_or_id}/model_versions/{model_version_id}/runs": {
    /**
     * Create Model Version Pipeline Run Link
     * @description Create a new model version to pipeline run link.
     *
     * Args:
     *     workspace_name_or_id: Name or ID of the workspace.
     *     model_version_id: ID of the model version.
     *     model_version_pipeline_run_link: The model version to pipeline run link to create.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     - If Model Version to Pipeline Run Link already exists - returns the existing link.
     *     - Otherwise, returns the newly created model version to pipeline run link.
     *
     * Raises:
     *     IllegalOperationError: If the workspace or user specified in the
     *         model version does not match the current workspace or authenticated
     *         user.
     */
    post: operations["create_model_version_pipeline_run_link_api_v1_workspaces__workspace_name_or_id__model_versions__model_version_id__runs_post"];
  };
  "/api/v1/flavors": {
    /**
     * List Flavors
     * @description Returns all flavors.
     *
     * Args:
     *     flavor_filter_model: Filter model used for pagination, sorting,
     *                          filtering
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     All flavors.
     */
    get: operations["list_flavors_api_v1_flavors_get"];
    /**
     * Create Flavor
     * @description Creates a stack component flavor.
     *
     * Args:
     *     flavor: Stack component flavor to register.
     *
     * Returns:
     *     The created stack component flavor.
     */
    post: operations["create_flavor_api_v1_flavors_post"];
  };
  "/api/v1/flavors/{flavor_id}": {
    /**
     * Get Flavor
     * @description Returns the requested flavor.
     *
     * Args:
     *     flavor_id: ID of the flavor.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The requested stack.
     */
    get: operations["get_flavor_api_v1_flavors__flavor_id__get"];
    /**
     * Update Flavor
     * @description Updates a flavor.
     *
     * # noqa: DAR401
     *
     * Args:
     *     flavor_id: ID of the flavor to update.
     *     flavor_update: Flavor update.
     *
     * Returns:
     *     The updated flavor.
     */
    put: operations["update_flavor_api_v1_flavors__flavor_id__put"];
    /**
     * Delete Flavor
     * @description Deletes a flavor.
     *
     * Args:
     *     flavor_id: ID of the flavor.
     */
    delete: operations["delete_flavor_api_v1_flavors__flavor_id__delete"];
  };
  "/api/v1/flavors/sync": {
    /**
     * Sync Flavors
     * @description Purge all in-built and integration flavors from the DB and sync.
     *
     * Returns:
     *     None if successful. Raises an exception otherwise.
     */
    patch: operations["sync_flavors_api_v1_flavors_sync_patch"];
  };
  "/api/v1/runs": {
    /**
     * List Runs
     * @description Get pipeline runs according to query filters.
     *
     * Args:
     *     runs_filter_model: Filter model used for pagination, sorting, filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The pipeline runs according to query filters.
     */
    get: operations["list_runs_api_v1_runs_get"];
  };
  "/api/v1/runs/{run_id}": {
    /**
     * Get Run
     * @description Get a specific pipeline run using its ID.
     *
     * Args:
     *     run_id: ID of the pipeline run to get.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The pipeline run.
     */
    get: operations["get_run_api_v1_runs__run_id__get"];
    /**
     * Update Run
     * @description Updates a run.
     *
     * Args:
     *     run_id: ID of the run.
     *     run_model: Run model to use for the update.
     *
     * Returns:
     *     The updated run model.
     */
    put: operations["update_run_api_v1_runs__run_id__put"];
    /**
     * Delete Run
     * @description Deletes a run.
     *
     * Args:
     *     run_id: ID of the run.
     */
    delete: operations["delete_run_api_v1_runs__run_id__delete"];
  };
  "/api/v1/runs/{run_id}/graph": {
    /**
     * Get Run Dag
     * @description Get the DAG for a given pipeline run.
     *
     * Args:
     *     run_id: ID of the pipeline run to use to get the DAG.
     *
     * Returns:
     *     The DAG for a given pipeline run.
     */
    get: operations["get_run_dag_api_v1_runs__run_id__graph_get"];
  };
  "/api/v1/runs/{run_id}/steps": {
    /**
     * Get Run Steps
     * @description Get all steps for a given pipeline run.
     *
     * Args:
     *     run_id: ID of the pipeline run.
     *     step_run_filter_model: Filter model used for pagination, sorting,
     *         filtering
     *
     * Returns:
     *     The steps for a given pipeline run.
     */
    get: operations["get_run_steps_api_v1_runs__run_id__steps_get"];
  };
  "/api/v1/runs/{run_id}/pipeline-configuration": {
    /**
     * Get Pipeline Configuration
     * @description Get the pipeline configuration of a specific pipeline run using its ID.
     *
     * Args:
     *     run_id: ID of the pipeline run to get.
     *
     * Returns:
     *     The pipeline configuration of the pipeline run.
     */
    get: operations["get_pipeline_configuration_api_v1_runs__run_id__pipeline_configuration_get"];
  };
  "/api/v1/runs/{run_id}/status": {
    /**
     * Get Run Status
     * @description Get the status of a specific pipeline run.
     *
     * Args:
     *     run_id: ID of the pipeline run for which to get the status.
     *
     * Returns:
     *     The status of the pipeline run.
     */
    get: operations["get_run_status_api_v1_runs__run_id__status_get"];
  };
  "/api/v1/run-metadata": {
    /**
     * List Run Metadata
     * @description Get run metadata according to query filters.
     *
     * Args:
     *     run_metadata_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The pipeline runs according to query filters.
     */
    get: operations["list_run_metadata_api_v1_run_metadata_get"];
  };
  "/api/v1/run-metadata/{run_metadata_id}": {
    /**
     * Get Run Metadata
     * @description Get run metadata by ID.
     *
     * Args:
     *     run_metadata_id: The ID of run metadata.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The run metadata response.
     */
    get: operations["get_run_metadata_api_v1_run_metadata__run_metadata_id__get"];
  };
  "/api/v1/schedules": {
    /**
     * List Schedules
     * @description Gets a list of schedules.
     *
     * Args:
     *     schedule_filter_model: Filter model used for pagination, sorting,
     *         filtering
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     List of schedule objects.
     */
    get: operations["list_schedules_api_v1_schedules_get"];
  };
  "/api/v1/schedules/{schedule_id}": {
    /**
     * Get Schedule
     * @description Gets a specific schedule using its unique id.
     *
     * Args:
     *     schedule_id: ID of the schedule to get.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     A specific schedule object.
     */
    get: operations["get_schedule_api_v1_schedules__schedule_id__get"];
    /**
     * Update Schedule
     * @description Updates the attribute on a specific schedule using its unique id.
     *
     * Args:
     *     schedule_id: ID of the schedule to get.
     *     schedule_update: the model containing the attributes to update.
     *
     * Returns:
     *     The updated schedule object.
     */
    put: operations["update_schedule_api_v1_schedules__schedule_id__put"];
    /**
     * Delete Schedule
     * @description Deletes a specific schedule using its unique id.
     *
     * Args:
     *     schedule_id: ID of the schedule to delete.
     */
    delete: operations["delete_schedule_api_v1_schedules__schedule_id__delete"];
  };
  "/api/v1/secrets": {
    /**
     * List Secrets
     * @description Gets a list of secrets.
     *
     * Args:
     *     secret_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     List of secret objects.
     */
    get: operations["list_secrets_api_v1_secrets_get"];
  };
  "/api/v1/secrets/{secret_id}": {
    /**
     * Get Secret
     * @description Gets a specific secret using its unique id.
     *
     * Args:
     *     secret_id: ID of the secret to get.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     A specific secret object.
     */
    get: operations["get_secret_api_v1_secrets__secret_id__get"];
    /**
     * Update Secret
     * @description Updates the attribute on a specific secret using its unique id.
     *
     * Args:
     *     secret_id: ID of the secret to get.
     *     secret_update: the model containing the attributes to update.
     *     patch_values: Whether to patch the secret values or replace them.
     *
     * Returns:
     *     The updated secret object.
     */
    put: operations["update_secret_api_v1_secrets__secret_id__put"];
    /**
     * Delete Secret
     * @description Deletes a specific secret using its unique id.
     *
     * Args:
     *     secret_id: ID of the secret to delete.
     */
    delete: operations["delete_secret_api_v1_secrets__secret_id__delete"];
  };
  "/api/v1/version": {
    /**
     * Version
     * @description Get version of the server.
     *
     * Returns:
     *     String representing the version of the server.
     */
    get: operations["version_api_v1_version_get"];
  };
  "/api/v1/info": {
    /**
     * Server Info
     * @description Get information about the server.
     *
     * Returns:
     *     Information about the server.
     */
    get: operations["server_info_api_v1_info_get"];
  };
  "/api/v1/service_accounts": {
    /**
     * List Service Accounts
     * @description Returns a list of service accounts.
     *
     * Args:
     *     filter_model: Model that takes care of filtering, sorting and
     *         pagination.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     A list of service accounts matching the filter.
     */
    get: operations["list_service_accounts_api_v1_service_accounts_get"];
    /**
     * Create Service Account
     * @description Creates a service account.
     *
     * Args:
     *     service_account: Service account to create.
     *
     * Returns:
     *     The created service account.
     */
    post: operations["create_service_account_api_v1_service_accounts_post"];
  };
  "/api/v1/service_accounts/{service_account_name_or_id}": {
    /**
     * Get Service Account
     * @description Returns a specific service account.
     *
     * Args:
     *     service_account_name_or_id: Name or ID of the service account.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The service account matching the given name or ID.
     */
    get: operations["get_service_account_api_v1_service_accounts__service_account_name_or_id__get"];
    /**
     * Update Service Account
     * @description Updates a specific service account.
     *
     * Args:
     *     service_account_name_or_id: Name or ID of the service account.
     *     service_account_update: the service account to use for the update.
     *
     * Returns:
     *     The updated service account.
     */
    put: operations["update_service_account_api_v1_service_accounts__service_account_name_or_id__put"];
    /**
     * Delete Service Account
     * @description Delete a specific service account.
     *
     * Args:
     *     service_account_name_or_id: Name or ID of the service account.
     */
    delete: operations["delete_service_account_api_v1_service_accounts__service_account_name_or_id__delete"];
  };
  "/api/v1/service_accounts/{service_account_id}/api_keys": {
    /**
     * List Api Keys
     * @description List API keys associated with a service account.
     *
     * Args:
     *     service_account_id: ID of the service account to which the API keys
     *         belong.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *     filter_model: Filter model used for pagination, sorting,
     *         filtering
     *
     * Returns:
     *     All API keys matching the filter and associated with the supplied
     *     service account.
     */
    get: operations["list_api_keys_api_v1_service_accounts__service_account_id__api_keys_get"];
    /**
     * Create Api Key
     * @description Creates an API key for a service account.
     *
     * Args:
     *     service_account_id: ID of the service account for which to create the
     *         API key.
     *     api_key: API key to create.
     *
     * Returns:
     *     The created API key.
     */
    post: operations["create_api_key_api_v1_service_accounts__service_account_id__api_keys_post"];
  };
  "/api/v1/service_accounts/{service_account_id}/api_keys/{api_key_name_or_id}": {
    /**
     * Get Api Key
     * @description Returns the requested API key.
     *
     * Args:
     *     service_account_id: ID of the service account to which the API key
     *         belongs.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *     api_key_name_or_id: Name or ID of the API key to return.
     *
     * Returns:
     *     The requested API key.
     */
    get: operations["get_api_key_api_v1_service_accounts__service_account_id__api_keys__api_key_name_or_id__get"];
    /**
     * Update Api Key
     * @description Updates an API key for a service account.
     *
     * Args:
     *     service_account_id: ID of the service account to which the API key
     *         belongs.
     *     api_key_name_or_id: Name or ID of the API key to update.
     *     api_key_update: API key update.
     *
     * Returns:
     *     The updated API key.
     */
    put: operations["update_api_key_api_v1_service_accounts__service_account_id__api_keys__api_key_name_or_id__put"];
    /**
     * Delete Api Key
     * @description Deletes an API key.
     *
     * Args:
     *     service_account_id: ID of the service account to which the API key
     *         belongs.
     *     api_key_name_or_id: Name or ID of the API key to delete.
     */
    delete: operations["delete_api_key_api_v1_service_accounts__service_account_id__api_keys__api_key_name_or_id__delete"];
  };
  "/api/v1/service_accounts/{service_account_id}/api_keys/{api_key_name_or_id}/rotate": {
    /**
     * Rotate Api Key
     * @description Rotate an API key.
     *
     * Args:
     *     service_account_id: ID of the service account to which the API key
     *         belongs.
     *     api_key_name_or_id: Name or ID of the API key to rotate.
     *     rotate_request: API key rotation request.
     *
     * Returns:
     *     The updated API key.
     */
    put: operations["rotate_api_key_api_v1_service_accounts__service_account_id__api_keys__api_key_name_or_id__rotate_put"];
  };
  "/api/v1/service_connectors": {
    /**
     * List Service Connectors
     * @description Get a list of all service connectors for a specific type.
     *
     * Args:
     *     connector_filter_model: Filter model used for pagination, sorting,
     *         filtering
     *     expand_secrets: Whether to expand secrets or not.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     Page with list of service connectors for a specific type.
     */
    get: operations["list_service_connectors_api_v1_service_connectors_get"];
  };
  "/api/v1/service_connectors/{connector_id}": {
    /**
     * Get Service Connector
     * @description Returns the requested service connector.
     *
     * Args:
     *     connector_id: ID of the service connector.
     *     expand_secrets: Whether to expand secrets or not.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The requested service connector.
     */
    get: operations["get_service_connector_api_v1_service_connectors__connector_id__get"];
    /**
     * Update Service Connector
     * @description Updates a service connector.
     *
     * Args:
     *     connector_id: ID of the service connector.
     *     connector_update: Service connector to use to update.
     *
     * Returns:
     *     Updated service connector.
     */
    put: operations["update_service_connector_api_v1_service_connectors__connector_id__put"];
    /**
     * Delete Service Connector
     * @description Deletes a service connector.
     *
     * Args:
     *     connector_id: ID of the service connector.
     */
    delete: operations["delete_service_connector_api_v1_service_connectors__connector_id__delete"];
  };
  "/api/v1/service_connectors/verify": {
    /**
     * Validate And Verify Service Connector Config
     * @description Verifies if a service connector configuration has access to resources.
     *
     * This requires the service connector implementation to be installed
     * on the ZenML server, otherwise a 501 Not Implemented error will be
     * returned.
     *
     * Args:
     *     connector: The service connector configuration to verify.
     *     list_resources: If True, the list of all resources accessible
     *         through the service connector is returned.
     *
     * Returns:
     *     The list of resources that the service connector configuration has
     *     access to.
     */
    post: operations["validate_and_verify_service_connector_config_api_v1_service_connectors_verify_post"];
  };
  "/api/v1/service_connectors/{connector_id}/verify": {
    /**
     * Validate And Verify Service Connector
     * @description Verifies if a service connector instance has access to one or more resources.
     *
     * This requires the service connector implementation to be installed
     * on the ZenML server, otherwise a 501 Not Implemented error will be
     * returned.
     *
     * Args:
     *     connector_id: The ID of the service connector to verify.
     *     resource_type: The type of resource to verify access to.
     *     resource_id: The ID of the resource to verify access to.
     *     list_resources: If True, the list of all resources accessible
     *         through the service connector and matching the supplied resource
     *         type and ID are returned.
     *
     * Returns:
     *     The list of resources that the service connector has access to, scoped
     *     to the supplied resource type and ID, if provided.
     */
    put: operations["validate_and_verify_service_connector_api_v1_service_connectors__connector_id__verify_put"];
  };
  "/api/v1/service_connectors/{connector_id}/client": {
    /**
     * Get Service Connector Client
     * @description Get a service connector client for a service connector and given resource.
     *
     * This requires the service connector implementation to be installed
     * on the ZenML server, otherwise a 501 Not Implemented error will be
     * returned.
     *
     * Args:
     *     connector_id: ID of the service connector.
     *     resource_type: Type of the resource to list.
     *     resource_id: ID of the resource to list.
     *
     * Returns:
     *     A service connector client that can be used to access the given
     *     resource.
     */
    get: operations["get_service_connector_client_api_v1_service_connectors__connector_id__client_get"];
  };
  "/api/v1/service_connector_types": {
    /**
     * List Service Connector Types
     * @description Get a list of service connector types.
     *
     * Args:
     *     connector_type: Filter by connector type.
     *     resource_type: Filter by resource type.
     *     auth_method: Filter by auth method.
     *
     * Returns:
     *     List of service connector types.
     */
    get: operations["list_service_connector_types_api_v1_service_connector_types_get"];
  };
  "/api/v1/service_connector_types/{connector_type}": {
    /**
     * Get Service Connector Type
     * @description Returns the requested service connector type.
     *
     * Args:
     *     connector_type: the service connector type identifier.
     *
     * Returns:
     *     The requested service connector type.
     */
    get: operations["get_service_connector_type_api_v1_service_connector_types__connector_type__get"];
  };
  "/api/v1/stacks": {
    /**
     * List Stacks
     * @description Returns all stacks.
     *
     * Args:
     *     stack_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     All stacks.
     */
    get: operations["list_stacks_api_v1_stacks_get"];
  };
  "/api/v1/stacks/{stack_id}": {
    /**
     * Get Stack
     * @description Returns the requested stack.
     *
     * Args:
     *     stack_id: ID of the stack.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The requested stack.
     */
    get: operations["get_stack_api_v1_stacks__stack_id__get"];
    /**
     * Update Stack
     * @description Updates a stack.
     *
     * Args:
     *     stack_id: Name of the stack.
     *     stack_update: Stack to use for the update.
     *
     * Returns:
     *     The updated stack.
     */
    put: operations["update_stack_api_v1_stacks__stack_id__put"];
    /**
     * Delete Stack
     * @description Deletes a stack.
     *
     * Args:
     *     stack_id: Name of the stack.
     */
    delete: operations["delete_stack_api_v1_stacks__stack_id__delete"];
  };
  "/api/v1/components": {
    /**
     * List Stack Components
     * @description Get a list of all stack components for a specific type.
     *
     * Args:
     *     component_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     List of stack components for a specific type.
     */
    get: operations["list_stack_components_api_v1_components_get"];
  };
  "/api/v1/components/{component_id}": {
    /**
     * Get Stack Component
     * @description Returns the requested stack component.
     *
     * Args:
     *     component_id: ID of the stack component.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The requested stack component.
     */
    get: operations["get_stack_component_api_v1_components__component_id__get"];
    /**
     * Update Stack Component
     * @description Updates a stack component.
     *
     * Args:
     *     component_id: ID of the stack component.
     *     component_update: Stack component to use to update.
     *
     * Returns:
     *     Updated stack component.
     */
    put: operations["update_stack_component_api_v1_components__component_id__put"];
    /**
     * Deregister Stack Component
     * @description Deletes a stack component.
     *
     * Args:
     *     component_id: ID of the stack component.
     */
    delete: operations["deregister_stack_component_api_v1_components__component_id__delete"];
  };
  "/api/v1/component-types": {
    /**
     * Get Stack Component Types
     * @description Get a list of all stack component types.
     *
     * Returns:
     *     List of stack components.
     */
    get: operations["get_stack_component_types_api_v1_component_types_get"];
  };
  "/api/v1/steps": {
    /**
     * List Run Steps
     * @description Get run steps according to query filters.
     *
     * Args:
     *     step_run_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     The run steps according to query filters.
     */
    get: operations["list_run_steps_api_v1_steps_get"];
    /**
     * Create Run Step
     * @description Create a run step.
     *
     * Args:
     *     step: The run step to create.
     *
     * Returns:
     *     The created run step.
     */
    post: operations["create_run_step_api_v1_steps_post"];
  };
  "/api/v1/steps/{step_id}": {
    /**
     * Get Step
     * @description Get one specific step.
     *
     * Args:
     *     step_id: ID of the step to get.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The step.
     */
    get: operations["get_step_api_v1_steps__step_id__get"];
    /**
     * Update Step
     * @description Updates a step.
     *
     * Args:
     *     step_id: ID of the step.
     *     step_model: Step model to use for the update.
     *
     * Returns:
     *     The updated step model.
     */
    put: operations["update_step_api_v1_steps__step_id__put"];
  };
  "/api/v1/steps/{step_id}/step-configuration": {
    /**
     * Get Step Configuration
     * @description Get the configuration of a specific step.
     *
     * Args:
     *     step_id: ID of the step to get.
     *
     * Returns:
     *     The step configuration.
     */
    get: operations["get_step_configuration_api_v1_steps__step_id__step_configuration_get"];
  };
  "/api/v1/steps/{step_id}/status": {
    /**
     * Get Step Status
     * @description Get the status of a specific step.
     *
     * Args:
     *     step_id: ID of the step for which to get the status.
     *
     * Returns:
     *     The status of the step.
     */
    get: operations["get_step_status_api_v1_steps__step_id__status_get"];
  };
  "/api/v1/steps/{step_id}/logs": {
    /**
     * Get Step Logs
     * @description Get the logs of a specific step.
     *
     * Args:
     *     step_id: ID of the step for which to get the logs.
     *
     * Returns:
     *     The logs of the step.
     *
     * Raises:
     *     HTTPException: If no logs are available for this step.
     */
    get: operations["get_step_logs_api_v1_steps__step_id__logs_get"];
  };
  "/api/v1/artifacts": {
    /**
     * List Artifacts
     * @description Get artifacts according to query filters.
     *
     * Args:
     *     artifact_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The artifacts according to query filters.
     */
    get: operations["list_artifacts_api_v1_artifacts_get"];
    /**
     * Create Artifact
     * @description Create a new artifact.
     *
     * Args:
     *     artifact: The artifact to create.
     *
     * Returns:
     *     The created artifact.
     */
    post: operations["create_artifact_api_v1_artifacts_post"];
  };
  "/api/v1/artifacts/{artifact_id}": {
    /**
     * Get Artifact
     * @description Get an artifact by ID.
     *
     * Args:
     *     artifact_id: The ID of the artifact to get.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The artifact with the given ID.
     */
    get: operations["get_artifact_api_v1_artifacts__artifact_id__get"];
    /**
     * Update Artifact
     * @description Update an artifact by ID.
     *
     * Args:
     *     artifact_id: The ID of the artifact to update.
     *     artifact_update: The update to apply to the artifact.
     *
     * Returns:
     *     The updated artifact.
     */
    put: operations["update_artifact_api_v1_artifacts__artifact_id__put"];
    /**
     * Delete Artifact
     * @description Delete an artifact by ID.
     *
     * Args:
     *     artifact_id: The ID of the artifact to delete.
     */
    delete: operations["delete_artifact_api_v1_artifacts__artifact_id__delete"];
  };
  "/api/v1/artifact_versions": {
    /**
     * List Artifact Versions
     * @description Get artifact versions according to query filters.
     *
     * Args:
     *     artifact_version_filter_model: Filter model used for pagination,
     *         sorting, filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *     auth_context: The authentication context.
     *
     * Returns:
     *     The artifact versions according to query filters.
     */
    get: operations["list_artifact_versions_api_v1_artifact_versions_get"];
    /**
     * Create Artifact Version
     * @description Create a new artifact version.
     *
     * Args:
     *     artifact_version: The artifact version to create.
     *
     * Returns:
     *     The created artifact version.
     */
    post: operations["create_artifact_version_api_v1_artifact_versions_post"];
  };
  "/api/v1/artifact_versions/{artifact_version_id}": {
    /**
     * Get Artifact Version
     * @description Get an artifact version by ID.
     *
     * Args:
     *     artifact_version_id: The ID of the artifact version to get.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The artifact version with the given ID.
     */
    get: operations["get_artifact_version_api_v1_artifact_versions__artifact_version_id__get"];
    /**
     * Update Artifact Version
     * @description Update an artifact by ID.
     *
     * Args:
     *     artifact_version_id: The ID of the artifact version to update.
     *     artifact_version_update: The update to apply to the artifact version.
     *
     * Returns:
     *     The updated artifact.
     */
    put: operations["update_artifact_version_api_v1_artifact_versions__artifact_version_id__put"];
    /**
     * Delete Artifact Version
     * @description Delete an artifact version by ID.
     *
     * Args:
     *     artifact_version_id: The ID of the artifact version to delete.
     */
    delete: operations["delete_artifact_version_api_v1_artifact_versions__artifact_version_id__delete"];
  };
  "/api/v1/artifact_versions/{artifact_version_id}/visualize": {
    /**
     * Get Artifact Visualization
     * @description Get the visualization of an artifact.
     *
     * Args:
     *     artifact_version_id: ID of the artifact version for which to get the visualization.
     *     index: Index of the visualization to get (if there are multiple).
     *
     * Returns:
     *     The visualization of the artifact version.
     */
    get: operations["get_artifact_visualization_api_v1_artifact_versions__artifact_version_id__visualize_get"];
  };
  "/api/v1/users": {
    /**
     * List Users
     * @description Returns a list of all users.
     *
     * Args:
     *     user_filter_model: Model that takes care of filtering, sorting and
     *         pagination.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     A list of all users.
     */
    get: operations["list_users_api_v1_users_get"];
    /**
     * Create User
     * @description Creates a user.
     *
     * # noqa: DAR401
     *
     * Args:
     *     user: User to create.
     *
     * Returns:
     *     The created user.
     */
    post: operations["create_user_api_v1_users_post"];
  };
  "/api/v1/users/{user_name_or_id}": {
    /**
     * Get User
     * @description Returns a specific user.
     *
     * Args:
     *     user_name_or_id: Name or ID of the user.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     A specific user.
     */
    get: operations["get_user_api_v1_users__user_name_or_id__get"];
    /**
     * Update User
     * @description Updates a specific user.
     *
     * Args:
     *     user_name_or_id: Name or ID of the user.
     *     user_update: the user to use for the update.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     The updated user.
     */
    put: operations["update_user_api_v1_users__user_name_or_id__put"];
    /**
     * Delete User
     * @description Deletes a specific user.
     *
     * Args:
     *     user_name_or_id: Name or ID of the user.
     *     auth_context: The authentication context.
     *
     * Raises:
     *     IllegalOperationError: If the user is not authorized to delete the user.
     */
    delete: operations["delete_user_api_v1_users__user_name_or_id__delete"];
  };
  "/api/v1/users/{user_name_or_id}/deactivate": {
    /**
     * Deactivate User
     * @description Deactivates a user and generates a new activation token for it.
     *
     * Args:
     *     user_name_or_id: Name or ID of the user.
     *     auth_context: Authentication context.
     *
     * Returns:
     *     The generated activation token.
     */
    put: operations["deactivate_user_api_v1_users__user_name_or_id__deactivate_put"];
  };
  "/api/v1/users/{user_name_or_id}/email-opt-in": {
    /**
     * Email Opt In Response
     * @description Sets the response of the user to the email prompt.
     *
     * Args:
     *     user_name_or_id: Name or ID of the user.
     *     user_response: User Response to email prompt
     *     auth_context: The authentication context of the user
     *
     * Returns:
     *     The updated user.
     *
     * Raises:
     *     AuthorizationException: if the user does not have the required
     *         permissions
     */
    put: operations["email_opt_in_response_api_v1_users__user_name_or_id__email_opt_in_put"];
  };
  "/api/v1/current-user": {
    /**
     * Get Current User
     * @description Returns the model of the authenticated user.
     *
     * Args:
     *     auth_context: The authentication context.
     *
     * Returns:
     *     The model of the authenticated user.
     */
    get: operations["get_current_user_api_v1_current_user_get"];
    /**
     * Update Myself
     * @description Updates a specific user.
     *
     * Args:
     *     user: the user to use for the update.
     *     auth_context: The authentication context.
     *
     * Returns:
     *     The updated user.
     */
    put: operations["update_myself_api_v1_current_user_put"];
  };
  "/api/v1/users/{user_name_or_id}/activate": {
    /**
     * Activate User
     * @description Activates a specific user.
     *
     * Args:
     *     user_name_or_id: Name or ID of the user.
     *     user_update: the user to use for the update.
     *
     * Returns:
     *     The updated user.
     */
    put: operations["activate_user_api_v1_users__user_name_or_id__activate_put"];
  };
  "/api/v1/pipeline_builds": {
    /**
     * List Builds
     * @description Gets a list of builds.
     *
     * Args:
     *     build_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     List of build objects.
     */
    get: operations["list_builds_api_v1_pipeline_builds_get"];
  };
  "/api/v1/pipeline_builds/{build_id}": {
    /**
     * Get Build
     * @description Gets a specific build using its unique id.
     *
     * Args:
     *     build_id: ID of the build to get.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     A specific build object.
     */
    get: operations["get_build_api_v1_pipeline_builds__build_id__get"];
    /**
     * Delete Build
     * @description Deletes a specific build.
     *
     * Args:
     *     build_id: ID of the build to delete.
     */
    delete: operations["delete_build_api_v1_pipeline_builds__build_id__delete"];
  };
  "/api/v1/pipeline_deployments": {
    /**
     * List Deployments
     * @description Gets a list of deployment.
     *
     * Args:
     *     deployment_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     List of deployment objects.
     */
    get: operations["list_deployments_api_v1_pipeline_deployments_get"];
  };
  "/api/v1/pipeline_deployments/{deployment_id}": {
    /**
     * Get Deployment
     * @description Gets a specific deployment using its unique id.
     *
     * Args:
     *     deployment_id: ID of the deployment to get.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     A specific deployment object.
     */
    get: operations["get_deployment_api_v1_pipeline_deployments__deployment_id__get"];
    /**
     * Delete Deployment
     * @description Deletes a specific deployment.
     *
     * Args:
     *     deployment_id: ID of the deployment to delete.
     */
    delete: operations["delete_deployment_api_v1_pipeline_deployments__deployment_id__delete"];
  };
  "/api/v1/code_repositories": {
    /**
     * List Code Repositories
     * @description Gets a page of code repositories.
     *
     * Args:
     *     filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     Page of code repository objects.
     */
    get: operations["list_code_repositories_api_v1_code_repositories_get"];
  };
  "/api/v1/code_repositories/{code_repository_id}": {
    /**
     * Get Code Repository
     * @description Gets a specific code repository using its unique ID.
     *
     * Args:
     *     code_repository_id: The ID of the code repository to get.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     A specific code repository object.
     */
    get: operations["get_code_repository_api_v1_code_repositories__code_repository_id__get"];
    /**
     * Update Code Repository
     * @description Updates a code repository.
     *
     * Args:
     *     code_repository_id: The ID of the code repository to update.
     *     update: The model containing the attributes to update.
     *
     * Returns:
     *     The updated code repository object.
     */
    put: operations["update_code_repository_api_v1_code_repositories__code_repository_id__put"];
    /**
     * Delete Code Repository
     * @description Deletes a specific code repository.
     *
     * Args:
     *     code_repository_id: The ID of the code repository to delete.
     */
    delete: operations["delete_code_repository_api_v1_code_repositories__code_repository_id__delete"];
  };
  "/api/v1/models": {
    /**
     * List Models
     * @description Get models according to query filters.
     *
     * Args:
     *     model_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The models according to query filters.
     */
    get: operations["list_models_api_v1_models_get"];
  };
  "/api/v1/models/{model_name_or_id}": {
    /**
     * Get Model
     * @description Get a model by name or ID.
     *
     * Args:
     *     model_name_or_id: The name or ID of the model to get.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The model with the given name or ID.
     */
    get: operations["get_model_api_v1_models__model_name_or_id__get"];
    /**
     * Delete Model
     * @description Delete a model by name or ID.
     *
     * Args:
     *     model_name_or_id: The name or ID of the model to delete.
     */
    delete: operations["delete_model_api_v1_models__model_name_or_id__delete"];
  };
  "/api/v1/models/{model_id}": {
    /**
     * Update Model
     * @description Updates a model.
     *
     * Args:
     *     model_id: Name of the stack.
     *     model_update: Stack to use for the update.
     *
     * Returns:
     *     The updated model.
     */
    put: operations["update_model_api_v1_models__model_id__put"];
  };
  "/api/v1/models/{model_name_or_id}/model_versions": {
    /**
     * List Model Versions
     * @description Get model versions according to query filters.
     *
     * This endpoint serves the purpose of allowing scoped filtering by model_id.
     *
     * Args:
     *     model_name_or_id: The name or ID of the model to list in.
     *     model_version_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *     auth_context: The authentication context.
     *
     * Returns:
     *     The model versions according to query filters.
     */
    get: operations["list_model_versions_api_v1_models__model_name_or_id__model_versions_get"];
  };
  "/api/v1/model_versions": {
    /**
     * List Model Versions
     * @description Get model versions according to query filters.
     *
     * Args:
     *     model_version_filter_model: Filter model used for pagination, sorting,
     *         filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *     auth_context: The authentication context.
     *
     * Returns:
     *     The model versions according to query filters.
     */
    get: operations["list_model_versions_api_v1_model_versions_get"];
  };
  "/api/v1/model_versions/{model_version_id}": {
    /**
     * Get Model Version
     * @description Get a model version by ID.
     *
     * Args:
     *     model_version_id: id of the model version to be retrieved.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The model version with the given name or ID.
     */
    get: operations["get_model_version_api_v1_model_versions__model_version_id__get"];
    /**
     * Update Model Version
     * @description Get all model versions by filter.
     *
     * Args:
     *     model_version_id: The ID of model version to be updated.
     *     model_version_update_model: The model version to be updated.
     *
     * Returns:
     *     An updated model version.
     */
    put: operations["update_model_version_api_v1_model_versions__model_version_id__put"];
    /**
     * Delete Model Version
     * @description Delete a model by name or ID.
     *
     * Args:
     *     model_version_id: The name or ID of the model version to delete.
     */
    delete: operations["delete_model_version_api_v1_model_versions__model_version_id__delete"];
  };
  "/api/v1/model_versions/{model_version_id}/artifacts/{model_version_artifact_link_name_or_id}": {
    /**
     * Delete Model Version Artifact Link
     * @description Deletes a model version link.
     *
     * Args:
     *     model_version_id: ID of the model version containing the link.
     *     model_version_artifact_link_name_or_id: name or ID of the model
     *         version to artifact link to be deleted.
     */
    delete: operations["delete_model_version_artifact_link_api_v1_model_versions__model_version_id__artifacts__model_version_artifact_link_name_or_id__delete"];
  };
  "/api/v1/model_versions/{model_version_id}/runs/{model_version_pipeline_run_link_name_or_id}": {
    /**
     * Delete Model Version Pipeline Run Link
     * @description Deletes a model version link.
     *
     * Args:
     *     model_version_id: name or ID of the model version containing the link.
     *     model_version_pipeline_run_link_name_or_id: name or ID of the model
     *         version link to be deleted.
     */
    delete: operations["delete_model_version_pipeline_run_link_api_v1_model_versions__model_version_id__runs__model_version_pipeline_run_link_name_or_id__delete"];
  };
  "/api/v1/model_version_artifacts": {
    /**
     * List Model Version Artifact Links
     * @description Get model version to artifact links according to query filters.
     *
     * Args:
     *     model_version_artifact_link_filter_model: Filter model used for
     *         pagination, sorting, filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The model version to artifact links according to query filters.
     */
    get: operations["list_model_version_artifact_links_api_v1_model_version_artifacts_get"];
  };
  "/api/v1/model_version_pipeline_runs": {
    /**
     * List Model Version Pipeline Run Links
     * @description Get model version to pipeline run links according to query filters.
     *
     * Args:
     *     model_version_pipeline_run_link_filter_model: Filter model used for
     *         pagination, sorting, and filtering.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The model version to pipeline run links according to query filters.
     */
    get: operations["list_model_version_pipeline_run_links_api_v1_model_version_pipeline_runs_get"];
  };
  "/api/v1/tags": {
    /**
     * List Tags
     * @description Get tags according to query filters.
     *
     * Args:
     *     tag_filter_model: Filter model used for pagination, sorting,
     *         filtering
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The tags according to query filters.
     */
    get: operations["list_tags_api_v1_tags_get"];
    /**
     * Create Tag
     * @description Create a new tag.
     *
     * Args:
     *     tag: The tag to create.
     *
     * Returns:
     *     The created tag.
     */
    post: operations["create_tag_api_v1_tags_post"];
  };
  "/api/v1/tags/{tag_name_or_id}": {
    /**
     * Get Tag
     * @description Get a tag by name or ID.
     *
     * Args:
     *     tag_name_or_id: The name or ID of the tag to get.
     *     hydrate: Flag deciding whether to hydrate the output model(s)
     *         by including metadata fields in the response.
     *
     * Returns:
     *     The tag with the given name or ID.
     */
    get: operations["get_tag_api_v1_tags__tag_name_or_id__get"];
    /**
     * Delete Tag
     * @description Delete a tag by name or ID.
     *
     * Args:
     *     tag_name_or_id: The name or ID of the tag to delete.
     */
    delete: operations["delete_tag_api_v1_tags__tag_name_or_id__delete"];
  };
  "/api/v1/tags/{tag_id}": {
    /**
     * Update Tag
     * @description Updates a tag.
     *
     * Args:
     *     tag_id: Id or name of the tag.
     *     tag_update_model: Tag to use for the update.
     *
     * Returns:
     *     The updated tag.
     */
    put: operations["update_tag_api_v1_tags__tag_id__put"];
  };
};

export type webhooks = Record<string, never>;

export type components = {
  schemas: {
    /**
     * APIKeyRequest
     * @description Request model for API keys.
     */
    APIKeyRequest: {
      /** The name of the API Key. */
      name: string;
      /** The description of the API Key. */
      description?: string;
    };
    /**
     * APIKeyResponse
     * @description Response model for API keys.
     */
    APIKeyResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["APIKeyResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["APIKeyResponseMetadata"];
      /** The name of the API Key. */
      name: string;
    };
    /**
     * APIKeyResponseBody
     * @description Response body for API keys.
     */
    APIKeyResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The API key. Only set immediately after creation or rotation. */
      key?: string;
      /**
       * Whether the API key is active.
       * @default true
       */
      active?: boolean;
      /** The service account associated with this API key. */
      service_account: components["schemas"]["ServiceAccountResponse"];
    };
    /**
     * APIKeyResponseMetadata
     * @description Response metadata for API keys.
     */
    APIKeyResponseMetadata: {
      /**
       * The description of the API Key.
       * @default
       */
      description?: string;
      /** Number of minutes for which the previous key is still valid after it has been rotated. */
      retain_period_minutes: number;
      /**
       * Time when the API key was last used to log in.
       * Format: date-time
       */
      last_login?: string;
      /**
       * Time when the API key was last rotated.
       * Format: date-time
       */
      last_rotated?: string;
    };
    /**
     * APIKeyRotateRequest
     * @description Request model for API key rotation.
     */
    APIKeyRotateRequest: {
      /**
       * Number of minutes for which the previous key is still valid after it has been rotated.
       * @default 0
       */
      retain_period_minutes?: number;
    };
    /**
     * APIKeyUpdate
     * @description Update model for API keys.
     */
    APIKeyUpdate: {
      /** The name of the API Key. */
      name?: string;
      /** The description of the API Key. */
      description?: string;
      /**
       * Whether the API key is active.
       * @default true
       */
      active?: boolean;
    };
    /**
     * ArtifactConfiguration
     * @description Class representing a complete input/output artifact configuration.
     */
    ArtifactConfiguration: {
      /** Materializer Source */
      materializer_source: components["schemas"]["Source"][];
      default_materializer_source?: components["schemas"]["Source"];
    };
    /**
     * ArtifactNode
     * @description A class that represents an artifact node in a lineage graph.
     */
    ArtifactNode: {
      /** Id */
      id: string;
      /**
       * Type
       * @default artifact
       */
      type?: string;
      data: components["schemas"]["ArtifactNodeDetails"];
    };
    /**
     * ArtifactNodeDetails
     * @description Captures all artifact details for the node.
     */
    ArtifactNodeDetails: {
      /** Execution Id */
      execution_id: string;
      /** Name */
      name: string;
      status: components["schemas"]["ArtifactNodeStatus"];
      /** Is Cached */
      is_cached: boolean;
      /** Artifact Type */
      artifact_type: string;
      /** Artifact Data Type */
      artifact_data_type: string;
      /** Parent Step Id */
      parent_step_id: string;
      /** Producer Step Id */
      producer_step_id?: string;
      /** Uri */
      uri: string;
      /** Metadata */
      metadata: [string, string, string][];
    };
    /**
     * ArtifactNodeStatus
     * @description Enum that represents the status of an artifact.
     * @enum {string}
     */
    ArtifactNodeStatus: "cached" | "created" | "external" | "unknown";
    /**
     * ArtifactRequest
     * @description Artifact request model.
     */
    ArtifactRequest: {
      /** Name of the artifact. */
      name: string;
      /**
       * Whether the name is custom (True) or auto-generated (False).
       * @default false
       */
      has_custom_name?: boolean;
    };
    /**
     * ArtifactResponse
     * @description Artifact response model.
     */
    ArtifactResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["ArtifactResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["ArtifactResponseMetadata"];
      /** Name of the output in the parent step. */
      name: string;
    };
    /**
     * ArtifactResponseBody
     * @description Response body for artifacts.
     */
    ArtifactResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** Tags associated with the model */
      tags: components["schemas"]["TagResponse"][];
    };
    /**
     * ArtifactResponseMetadata
     * @description Response metadata for artifacts.
     */
    ArtifactResponseMetadata: {
      /**
       * Whether the name is custom (True) or auto-generated (False).
       * @default false
       */
      has_custom_name?: boolean;
    };
    /**
     * ArtifactType
     * @description All possible types an artifact can have.
     * @enum {string}
     */
    ArtifactType: "DataAnalysisArtifact" | "DataArtifact" | "ModelArtifact" | "SchemaArtifact" | "ServiceArtifact" | "StatisticsArtifact" | "BaseArtifact";
    /**
     * ArtifactUpdate
     * @description Artifact update model.
     */
    ArtifactUpdate: {
      /** Name */
      name?: string;
      /** Add Tags */
      add_tags?: string[];
      /** Remove Tags */
      remove_tags?: string[];
    };
    /**
     * ArtifactVersionRequest
     * @description Request model for artifact versions.
     */
    ArtifactVersionRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /**
       * ID of the artifact to which this version belongs.
       * Format: uuid
       */
      artifact_id: string;
      /** Version of the artifact. */
      version: string | number;
      /**
       * Whether the name is custom (True) or auto-generated (False).
       * @default false
       */
      has_custom_name?: boolean;
      /** Type of the artifact. */
      type: components["schemas"]["ArtifactType"];
      /**
       * ID of the artifact store in which this artifact is stored.
       * Format: uuid
       */
      artifact_store_id?: string;
      /** URI of the artifact. */
      uri: string;
      /** Materializer class to use for this artifact. */
      materializer: components["schemas"]["Source"];
      /** Data type of the artifact. */
      data_type: components["schemas"]["Source"];
      /**
       * Tags of the artifact.
       * @description Should be a list of plain strings, e.g., ['tag1', 'tag2']
       */
      tags?: string[];
      /** Visualizations of the artifact. */
      visualizations?: components["schemas"]["ArtifactVisualizationRequest"][];
    };
    /**
     * ArtifactVersionResponse
     * @description Response model for artifact versions.
     */
    ArtifactVersionResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["ArtifactVersionResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["ArtifactVersionResponseMetadata"];
    };
    /**
     * ArtifactVersionResponseBody
     * @description Response body for artifact versions.
     */
    ArtifactVersionResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /** Artifact to which this version belongs. */
      artifact: components["schemas"]["ArtifactResponse"];
      /** Version of the artifact. */
      version: string | number;
      /** URI of the artifact. */
      uri: string;
      /** Type of the artifact. */
      type: components["schemas"]["ArtifactType"];
      /** Materializer class to use for this artifact. */
      materializer: components["schemas"]["Source"];
      /** Data type of the artifact. */
      data_type: components["schemas"]["Source"];
      /** Tags associated with the model */
      tags: components["schemas"]["TagResponse"][];
    };
    /**
     * ArtifactVersionResponseMetadata
     * @description Response metadata for artifact versions.
     */
    ArtifactVersionResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /**
       * ID of the artifact store in which this artifact is stored.
       * Format: uuid
       */
      artifact_store_id?: string;
      /**
       * ID of the step run that produced this artifact.
       * Format: uuid
       */
      producer_step_run_id?: string;
      /** Visualizations of the artifact. */
      visualizations?: components["schemas"]["ArtifactVisualizationResponse"][];
      /**
       * Metadata of the artifact.
       * @default {}
       */
      run_metadata?: {
        [key: string]: unknown;
      };
    };
    /**
     * ArtifactVersionUpdate
     * @description Artifact version update model.
     */
    ArtifactVersionUpdate: {
      /** Name */
      name?: string;
      /** Add Tags */
      add_tags?: string[];
      /** Remove Tags */
      remove_tags?: string[];
    };
    /**
     * ArtifactVisualizationRequest
     * @description Request model for artifact visualization.
     */
    ArtifactVisualizationRequest: {
      type: components["schemas"]["VisualizationType"];
      /** Uri */
      uri: string;
    };
    /**
     * ArtifactVisualizationResponse
     * @description Response model for artifact visualizations.
     */
    ArtifactVisualizationResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["ArtifactVisualizationResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["ArtifactVisualizationResponseMetadata"];
    };
    /**
     * ArtifactVisualizationResponseBody
     * @description Response body for artifact visualizations.
     */
    ArtifactVisualizationResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      type: components["schemas"]["VisualizationType"];
      /** Uri */
      uri: string;
    };
    /**
     * ArtifactVisualizationResponseMetadata
     * @description Response metadata model for artifact visualizations.
     */
    ArtifactVisualizationResponseMetadata: {
      /**
       * Artifact Version Id
       * Format: uuid
       */
      artifact_version_id: string;
    };
    /**
     * AuthScheme
     * @description The authentication scheme.
     * @enum {string}
     */
    AuthScheme: "NO_AUTH" | "HTTP_BASIC" | "OAUTH2_PASSWORD_BEARER" | "EXTERNAL";
    /**
     * AuthenticationMethodModel
     * @description Authentication method specification.
     *
     * Describes the schema for the configuration and secrets that need to be
     * provided to configure an authentication method.
     */
    AuthenticationMethodModel: {
      /** User readable name for the authentication method. */
      name: string;
      /** The name of the authentication method. */
      auth_method: string;
      /**
       * A description of the authentication method.
       * @default
       */
      description?: string;
      /** The JSON schema of the configuration for this authentication method. */
      config_schema?: {
        [key: string]: unknown;
      };
      /** The minimum number of seconds that the authentication session can be configured to be valid for. Set to None for authentication sessions and long-lived credentials that don't expire. */
      min_expiration_seconds?: number;
      /** The maximum number of seconds that the authentication session can be configured to be valid for. Set to None for authentication sessions and long-lived credentials that don't expire. */
      max_expiration_seconds?: number;
      /** The default number of seconds that the authentication session is valid for. Set to None for authentication sessions and long-lived credentials that don't expire. */
      default_expiration_seconds?: number;
    };
    /**
     * BaseResponseMetadata
     * @description Base metadata model.
     *
     * Used as a base class for all metadata models associated with responses.
     */
    BaseResponseMetadata: Record<string, never>;
    /**
     * BaseSettings
     * @description Base class for settings.
     *
     * The `LEVEL` class variable defines on which level the settings can be
     * specified. By default, subclasses can be defined on both pipelines and
     * steps.
     */
    BaseSettings: Record<string, never>;
    /** Body_device_authorization_api_v1_device_authorization_post */
    Body_device_authorization_api_v1_device_authorization_post: {
      /**
       * Client Id
       * Format: uuid
       */
      client_id: string;
    };
    /** Body_token_api_v1_login_post */
    Body_token_api_v1_login_post: {
      /** Grant Type */
      grant_type?: string;
      /** Username */
      username?: string;
      /** Password */
      password?: string;
      /** Client Id */
      client_id?: string;
      /** Device Code */
      device_code?: string;
    };
    /**
     * BuildItem
     * @description Pipeline build item.
     *
     * Attributes:
     *     image: The image name or digest.
     *     dockerfile: The contents of the Dockerfile used to build the image.
     *     requirements: The pip requirements installed in the image. This is a
     *         string consisting of multiple concatenated requirements.txt files.
     *     settings_checksum: Checksum of the settings used for the build.
     *     contains_code: Whether the image contains user files.
     *     requires_code_download: Whether the image needs to download files.
     */
    BuildItem: {
      /** The image name or digest. */
      image: string;
      /** The dockerfile used to build the image. */
      dockerfile?: string;
      /** The pip requirements installed in the image. */
      requirements?: string;
      /** The checksum of the build settings. */
      settings_checksum?: string;
      /**
       * Whether the image contains user files.
       * @default true
       */
      contains_code?: boolean;
      /**
       * Whether the image needs to download files.
       * @default false
       */
      requires_code_download?: boolean;
    };
    /**
     * CodeReferenceRequest
     * @description Request model for code references.
     */
    CodeReferenceRequest: {
      /**
       * Commit
       * @description The commit of the code reference.
       */
      commit: string;
      /**
       * Subdirectory
       * @description The subdirectory of the code reference.
       */
      subdirectory: string;
      /**
       * Code Repository
       * Format: uuid
       * @description The repository of the code reference.
       */
      code_repository: string;
    };
    /**
     * CodeReferenceResponse
     * @description Response model for code references.
     */
    CodeReferenceResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["CodeReferenceResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["CodeReferenceResponseMetadata"];
    };
    /**
     * CodeReferenceResponseBody
     * @description Response body for code references.
     */
    CodeReferenceResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /**
       * Commit
       * @description The commit of the code reference.
       */
      commit: string;
      /**
       * Subdirectory
       * @description The subdirectory of the code reference.
       */
      subdirectory: string;
      /**
       * Code Repository
       * @description The repository of the code reference.
       */
      code_repository: components["schemas"]["CodeRepositoryResponse"];
    };
    /**
     * CodeReferenceResponseMetadata
     * @description Response metadata for code references.
     */
    CodeReferenceResponseMetadata: Record<string, never>;
    /**
     * CodeRepositoryRequest
     * @description Request model for code repositories.
     */
    CodeRepositoryRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /** The name of the code repository. */
      name: string;
      /**
       * Config
       * @description Configuration for the code repository.
       */
      config: {
        [key: string]: unknown;
      };
      /**
       * Source
       * @description The code repository source.
       */
      source: components["schemas"]["Source"];
      /**
       * Logo Url
       * @description Optional URL of a logo (png, jpg or svg) for the code repository.
       */
      logo_url?: string;
      /**
       * Description
       * @description Code repository description.
       */
      description?: string;
    };
    /**
     * CodeRepositoryResponse
     * @description Response model for code repositories.
     */
    CodeRepositoryResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["CodeRepositoryResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["CodeRepositoryResponseMetadata"];
      /** The name of the code repository. */
      name: string;
    };
    /**
     * CodeRepositoryResponseBody
     * @description Response body for code repositories.
     */
    CodeRepositoryResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /**
       * Source
       * @description The code repository source.
       */
      source: components["schemas"]["Source"];
      /**
       * Logo Url
       * @description Optional URL of a logo (png, jpg or svg) for the code repository.
       */
      logo_url?: string;
    };
    /**
     * CodeRepositoryResponseMetadata
     * @description Response metadata for code repositories.
     */
    CodeRepositoryResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /**
       * Config
       * @description Configuration for the code repository.
       */
      config: {
        [key: string]: unknown;
      };
      /**
       * Description
       * @description Code repository description.
       */
      description?: string;
    };
    /**
     * CodeRepositoryUpdate
     * @description Update model for code repositories.
     */
    CodeRepositoryUpdate: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user?: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace?: string;
      /** The name of the code repository. */
      name?: string;
      /**
       * Config
       * @description Configuration for the code repository.
       */
      config?: {
        [key: string]: unknown;
      };
      /**
       * Source
       * @description The code repository source.
       */
      source?: components["schemas"]["Source"];
      /**
       * Logo Url
       * @description Optional URL of a logo (png, jpg or svg) for the code repository.
       */
      logo_url?: string;
      /**
       * Description
       * @description Code repository description.
       */
      description?: string;
    };
    /**
     * ColorVariants
     * @description All possible color variants for frontend.
     * @enum {string}
     */
    ColorVariants: "grey" | "purple" | "red" | "green" | "yellow" | "orange" | "lime" | "teal" | "turquoise" | "magenta" | "blue";
    /**
     * ComponentRequest
     * @description Request model for components.
     */
    ComponentRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /** The name of the stack component. */
      name: string;
      /** The type of the stack component. */
      type: components["schemas"]["StackComponentType"];
      /** The flavor of the stack component. */
      flavor: string;
      /** The stack component configuration. */
      configuration: {
        [key: string]: unknown;
      };
      /**
       * Connector Resource Id
       * @description The ID of a specific resource instance to gain access to through the connector
       */
      connector_resource_id?: string;
      /** The stack component labels. */
      labels?: {
        [key: string]: unknown;
      };
      /** The path to the component spec used for mlstacks deployments. */
      component_spec_path?: string;
      /**
       * The service connector linked to this stack component.
       * Format: uuid
       */
      connector?: string;
    };
    /**
     * ComponentResponse
     * @description Response model for components.
     */
    ComponentResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["ComponentResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["ComponentResponseMetadata"];
      /** The name of the stack component. */
      name: string;
    };
    /**
     * ComponentResponseBody
     * @description Response body for components.
     */
    ComponentResponseBody: {
      /**
       * The timestamp when this component was created.
       * Format: date-time
       */
      created: string;
      /**
       * The timestamp when this component was last updated.
       * Format: date-time
       */
      updated: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /** The type of the stack component. */
      type: components["schemas"]["StackComponentType"];
      /** The flavor of the stack component. */
      flavor: string;
    };
    /**
     * ComponentResponseMetadata
     * @description Response metadata for components.
     */
    ComponentResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /** The stack component configuration. */
      configuration: {
        [key: string]: unknown;
      };
      /** The stack component labels. */
      labels?: {
        [key: string]: unknown;
      };
      /** The path to the component spec used for mlstacks deployments. */
      component_spec_path?: string;
      /**
       * Connector Resource Id
       * @description The ID of a specific resource instance to gain access to through the connector
       */
      connector_resource_id?: string;
      /** The service connector linked to this stack component. */
      connector?: components["schemas"]["ServiceConnectorResponse"];
    };
    /**
     * ComponentUpdate
     * @description Update model for stack components.
     */
    ComponentUpdate: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user?: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace?: string;
      /** The name of the stack component. */
      name?: string;
      /** The type of the stack component. */
      type?: components["schemas"]["StackComponentType"];
      /** The flavor of the stack component. */
      flavor?: string;
      /** The stack component configuration. */
      configuration?: {
        [key: string]: unknown;
      };
      /**
       * Connector Resource Id
       * @description The ID of a specific resource instance to gain access to through the connector
       */
      connector_resource_id?: string;
      /** The stack component labels. */
      labels?: {
        [key: string]: unknown;
      };
      /** The path to the component spec used for mlstacks deployments. */
      component_spec_path?: string;
      /**
       * The service connector linked to this stack component.
       * Format: uuid
       */
      connector?: string;
    };
    /**
     * Edge
     * @description A class that represents an edge in a lineage graph.
     */
    Edge: {
      /** Id */
      id: string;
      /** Source */
      source: string;
      /** Target */
      target: string;
    };
    /**
     * ErrorModel
     * @description Base class for error responses.
     */
    ErrorModel: {
      /** Detail */
      detail?: unknown;
    };
    /**
     * ExecutionStatus
     * @description Enum that represents the current status of a step or pipeline run.
     * @enum {string}
     */
    ExecutionStatus: "failed" | "completed" | "running" | "cached";
    /**
     * ExternalArtifactConfiguration
     * @description External artifact configuration.
     *
     * Lightweight class to pass in the steps for runtime inference.
     */
    ExternalArtifactConfiguration: {
      /**
       * Id
       * Format: uuid
       */
      id?: string;
      /** Name */
      name?: string;
      /** Version */
      version?: string;
      model_version?: components["schemas"]["ModelVersion"];
    };
    /**
     * FlavorRequest
     * @description Request model for flavors.
     */
    FlavorRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /** The name of the Flavor. */
      name: string;
      /** The type of the Flavor. */
      type: components["schemas"]["StackComponentType"];
      /** The JSON schema of this flavor's corresponding configuration. */
      config_schema: {
        [key: string]: unknown;
      };
      /** The type of the connector that this flavor uses. */
      connector_type?: string;
      /** The resource type of the connector that this flavor uses. */
      connector_resource_type?: string;
      /** The name of an attribute in the stack component configuration that plays the role of resource ID when linked to a service connector. */
      connector_resource_id_attr?: string;
      /** The path to the module which contains this Flavor. */
      source: string;
      /** The name of the integration that the Flavor belongs to. */
      integration?: string;
      /** Optionally, a url pointing to a png,svg or jpg can be attached. */
      logo_url?: string;
      /** Optionally, a url pointing to docs, within docs.zenml.io. */
      docs_url?: string;
      /** Optionally, a url pointing to SDK docs,within sdkdocs.zenml.io. */
      sdk_docs_url?: string;
      /**
       * Whether or not this flavor is a custom, user created flavor.
       * @default true
       */
      is_custom?: boolean;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace?: string;
    };
    /**
     * FlavorResponse
     * @description Response model for flavors.
     */
    FlavorResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["FlavorResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["FlavorResponseMetadata"];
      /** The name of the Flavor. */
      name: string;
    };
    /**
     * FlavorResponseBody
     * @description Response body for flavor.
     */
    FlavorResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /** The type of the Flavor. */
      type: components["schemas"]["StackComponentType"];
      /** The name of the integration that the Flavor belongs to. */
      integration?: string;
      /** Optionally, a url pointing to a png,svg or jpg can be attached. */
      logo_url?: string;
    };
    /**
     * FlavorResponseMetadata
     * @description Response metadata for flavors.
     */
    FlavorResponseMetadata: {
      /** The project of this resource. */
      workspace?: components["schemas"]["WorkspaceResponse"];
      /** The JSON schema of this flavor's corresponding configuration. */
      config_schema: {
        [key: string]: unknown;
      };
      /** The type of the connector that this flavor uses. */
      connector_type?: string;
      /** The resource type of the connector that this flavor uses. */
      connector_resource_type?: string;
      /** The name of an attribute in the stack component configuration that plays the role of resource ID when linked to a service connector. */
      connector_resource_id_attr?: string;
      /** The path to the module which contains this Flavor. */
      source: string;
      /** Optionally, a url pointing to docs, within docs.zenml.io. */
      docs_url?: string;
      /** Optionally, a url pointing to SDK docs,within sdkdocs.zenml.io. */
      sdk_docs_url?: string;
      /**
       * Whether or not this flavor is a custom, user created flavor.
       * @default true
       */
      is_custom?: boolean;
    };
    /**
     * FlavorUpdate
     * @description Update model for flavors.
     */
    FlavorUpdate: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user?: string;
      /** The name of the Flavor. */
      name?: string;
      /** The type of the Flavor. */
      type?: components["schemas"]["StackComponentType"];
      /** The JSON schema of this flavor's corresponding configuration. */
      config_schema?: {
        [key: string]: unknown;
      };
      /** The type of the connector that this flavor uses. */
      connector_type?: string;
      /** The resource type of the connector that this flavor uses. */
      connector_resource_type?: string;
      /** The name of an attribute in the stack component configuration that plays the role of resource ID when linked to a service connector. */
      connector_resource_id_attr?: string;
      /** The path to the module which contains this Flavor. */
      source?: string;
      /** The name of the integration that the Flavor belongs to. */
      integration?: string;
      /** Optionally, a url pointing to a png,svg or jpg can be attached. */
      logo_url?: string;
      /** Optionally, a url pointing to docs, within docs.zenml.io. */
      docs_url?: string;
      /** Optionally, a url pointing to SDK docs,within sdkdocs.zenml.io. */
      sdk_docs_url?: string;
      /**
       * Whether or not this flavor is a custom, user created flavor.
       * @default true
       */
      is_custom?: boolean;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace?: string;
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components["schemas"]["ValidationError"][];
    };
    /**
     * InputSpec
     * @description Step input specification.
     */
    InputSpec: {
      /** Step Name */
      step_name: string;
      /** Output Name */
      output_name: string;
    };
    /**
     * LineageGraph
     * @description A lineage graph representation of a PipelineRunResponseModel.
     */
    LineageGraph: {
      /**
       * Nodes
       * @default []
       */
      nodes?: (components["schemas"]["StepNode"] | components["schemas"]["ArtifactNode"])[];
      /**
       * Edges
       * @default []
       */
      edges?: components["schemas"]["Edge"][];
      /** Root Step Id */
      root_step_id?: string;
      /**
       * Run Metadata
       * @default []
       */
      run_metadata?: [string, string, string][];
    };
    /**
     * LoadedVisualization
     * @description Model for loaded visualizations.
     */
    LoadedVisualization: {
      type: components["schemas"]["VisualizationType"];
      /** Value */
      value: string;
    };
    /**
     * LogicalOperators
     * @description Logical Ops to use to combine filters on list methods.
     * @enum {string}
     */
    LogicalOperators: "or" | "and";
    /**
     * LogsRequest
     * @description Request model for logs.
     */
    LogsRequest: {
      /** The uri of the logs file */
      uri: string;
      /** The artifact store ID to associate the logs with. */
      artifact_store_id: string;
    };
    /**
     * LogsResponse
     * @description Response model for logs.
     */
    LogsResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["LogsResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["LogsResponseMetadata"];
    };
    /**
     * LogsResponseBody
     * @description Response body for logs.
     */
    LogsResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The uri of the logs file */
      uri: string;
    };
    /**
     * LogsResponseMetadata
     * @description Response metadata for logs.
     */
    LogsResponseMetadata: {
      /**
       * Step ID to associate the logs with.
       * @description When this is set, pipeline_run_id should be set to None.
       */
      step_run_id?: string;
      /**
       * Pipeline run ID to associate the logs with.
       * @description When this is set, step_run_id should be set to None.
       */
      pipeline_run_id?: string;
      /** The artifact store ID to associate the logs with. */
      artifact_store_id: string;
    };
    /**
     * MetadataResourceTypes
     * @description All possible resource types for adding metadata.
     * @enum {string}
     */
    MetadataResourceTypes: "pipeline_run" | "step_run" | "artifact_version" | "model_version";
    /**
     * MetadataTypeEnum
     * @description String Enum of all possible types that metadata can have.
     * @enum {string}
     */
    MetadataTypeEnum: "str" | "int" | "float" | "bool" | "list" | "dict" | "tuple" | "set" | "Uri" | "Path" | "DType" | "StorageSize";
    /**
     * ModelRequest
     * @description Request model for models.
     */
    ModelRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /** The name of the model */
      name: string;
      /** The license model created under */
      license?: string;
      /** The description of the model */
      description?: string;
      /** The target audience of the model */
      audience?: string;
      /** The use cases of the model */
      use_cases?: string;
      /** The know limitations of the model */
      limitations?: string;
      /** The trade offs of the model */
      trade_offs?: string;
      /** The ethical implications of the model */
      ethics?: string;
      /** Tags associated with the model */
      tags?: string[];
    };
    /**
     * ModelResponse
     * @description Response model for models.
     */
    ModelResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["ModelResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["ModelResponseMetadata"];
      /** The name of the model */
      name: string;
    };
    /**
     * ModelResponseBody
     * @description Response body for models.
     */
    ModelResponseBody: {
      /**
       * The timestamp when this component was created.
       * Format: date-time
       */
      created: string;
      /**
       * The timestamp when this component was last updated.
       * Format: date-time
       */
      updated: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /** Tags associated with the model */
      tags: components["schemas"]["TagResponse"][];
      /** Latest Version */
      latest_version?: string;
    };
    /**
     * ModelResponseMetadata
     * @description Response metadata for models.
     */
    ModelResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /** The license model created under */
      license?: string;
      /** The description of the model */
      description?: string;
      /** The target audience of the model */
      audience?: string;
      /** The use cases of the model */
      use_cases?: string;
      /** The know limitations of the model */
      limitations?: string;
      /** The trade offs of the model */
      trade_offs?: string;
      /** The ethical implications of the model */
      ethics?: string;
    };
    /**
     * ModelStages
     * @description All possible stages of a Model Version.
     * @enum {string}
     */
    ModelStages: "none" | "staging" | "production" | "archived" | "latest";
    /**
     * ModelUpdate
     * @description Update model for models.
     */
    ModelUpdate: {
      /** License */
      license?: string;
      /** Description */
      description?: string;
      /** Audience */
      audience?: string;
      /** Use Cases */
      use_cases?: string;
      /** Limitations */
      limitations?: string;
      /** Trade Offs */
      trade_offs?: string;
      /** Ethics */
      ethics?: string;
      /** Add Tags */
      add_tags?: string[];
      /** Remove Tags */
      remove_tags?: string[];
    };
    /**
     * ModelVersion
     * @description ModelVersion class to pass into pipeline or step to set it into a model context.
     *
     * name: The name of the model.
     * license: The license under which the model is created.
     * description: The description of the model.
     * audience: The target audience of the model.
     * use_cases: The use cases of the model.
     * limitations: The known limitations of the model.
     * trade_offs: The tradeoffs of the model.
     * ethics: The ethical implications of the model.
     * tags: Tags associated with the model.
     * version: The model version name, number or stage is optional and points model context
     *     to a specific version/stage. If skipped new model version will be created.
     * save_models_to_registry: Whether to save all ModelArtifacts to Model Registry,
     *     if available in active stack.
     */
    ModelVersion: {
      /** Name */
      name: string;
      /** License */
      license?: string;
      /** Description */
      description?: string;
      /** Audience */
      audience?: string;
      /** Use Cases */
      use_cases?: string;
      /** Limitations */
      limitations?: string;
      /** Trade Offs */
      trade_offs?: string;
      /** Ethics */
      ethics?: string;
      /** Tags */
      tags?: string[];
      /** Version */
      version?: components["schemas"]["ModelStages"] | number | string;
      /**
       * Save Models To Registry
       * @default true
       */
      save_models_to_registry?: boolean;
      /**
       * Suppress Class Validation Warnings
       * @default false
       */
      suppress_class_validation_warnings?: boolean;
      /**
       * Was Created In This Run
       * @default false
       */
      was_created_in_this_run?: boolean;
    };
    /**
     * ModelVersionArtifactRequest
     * @description Request model for links between model versions and artifacts.
     */
    ModelVersionArtifactRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /**
       * Model
       * Format: uuid
       */
      model: string;
      /**
       * Model Version
       * Format: uuid
       */
      model_version: string;
      /**
       * Artifact Version
       * Format: uuid
       */
      artifact_version: string;
      /**
       * Is Model Artifact
       * @default false
       */
      is_model_artifact?: boolean;
      /**
       * Is Deployment Artifact
       * @default false
       */
      is_deployment_artifact?: boolean;
    };
    /**
     * ModelVersionArtifactResponse
     * @description Response model for links between model versions and artifacts.
     */
    ModelVersionArtifactResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["ModelVersionArtifactResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["BaseResponseMetadata"];
    };
    /**
     * ModelVersionArtifactResponseBody
     * @description Response body for links between model versions and artifacts.
     */
    ModelVersionArtifactResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /**
       * Model
       * Format: uuid
       */
      model: string;
      /**
       * Model Version
       * Format: uuid
       */
      model_version: string;
      artifact_version: components["schemas"]["ArtifactVersionResponse"];
      /**
       * Is Model Artifact
       * @default false
       */
      is_model_artifact?: boolean;
      /**
       * Is Deployment Artifact
       * @default false
       */
      is_deployment_artifact?: boolean;
    };
    /**
     * ModelVersionPipelineRunRequest
     * @description Request model for links between model versions and pipeline runs.
     */
    ModelVersionPipelineRunRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /**
       * Model
       * Format: uuid
       */
      model: string;
      /**
       * Model Version
       * Format: uuid
       */
      model_version: string;
      /**
       * Pipeline Run
       * Format: uuid
       */
      pipeline_run: string;
    };
    /**
     * ModelVersionPipelineRunResponse
     * @description Response model for links between model versions and pipeline runs.
     */
    ModelVersionPipelineRunResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["ModelVersionPipelineRunResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["BaseResponseMetadata"];
    };
    /**
     * ModelVersionPipelineRunResponseBody
     * @description Response body for links between model versions and pipeline runs.
     */
    ModelVersionPipelineRunResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /**
       * Model
       * Format: uuid
       */
      model: string;
      /**
       * Model Version
       * Format: uuid
       */
      model_version: string;
      pipeline_run: components["schemas"]["PipelineRunResponse"];
    };
    /**
     * ModelVersionRequest
     * @description Request model for model versions.
     */
    ModelVersionRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /**
       * Name
       * @description The name of the model version
       */
      name?: string;
      /**
       * Description
       * @description The description of the model version
       */
      description?: string;
      /**
       * Stage
       * @description The stage of the model version
       */
      stage?: string;
      /**
       * Number
       * @description The number of the model version
       */
      number?: number;
      /**
       * Model
       * Format: uuid
       * @description The ID of the model containing version
       */
      model: string;
      /** Tags associated with the model version */
      tags?: string[];
    };
    /**
     * ModelVersionResponse
     * @description Response model for model versions.
     */
    ModelVersionResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["ModelVersionResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["ModelVersionResponseMetadata"];
      /**
       * Name
       * @description The name of the model version
       */
      name?: string;
    };
    /**
     * ModelVersionResponseBody
     * @description Response body for model versions.
     */
    ModelVersionResponseBody: {
      /**
       * The timestamp when this component was created.
       * Format: date-time
       */
      created: string;
      /**
       * The timestamp when this component was last updated.
       * Format: date-time
       */
      updated: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /**
       * Stage
       * @description The stage of the model version
       */
      stage?: string;
      /**
       * Number
       * @description The number of the model version
       */
      number: number;
      /**
       * Model
       * @description The model containing version
       */
      model: components["schemas"]["ModelResponse"];
      /**
       * Model Artifact Ids
       * @description Model artifacts linked to the model version
       * @default {}
       */
      model_artifact_ids?: {
        [key: string]: unknown;
      };
      /**
       * Data Artifact Ids
       * @description Data artifacts linked to the model version
       * @default {}
       */
      data_artifact_ids?: {
        [key: string]: unknown;
      };
      /**
       * Deployment Artifact Ids
       * @description Deployment artifacts linked to the model version
       * @default {}
       */
      deployment_artifact_ids?: {
        [key: string]: unknown;
      };
      /**
       * Pipeline Run Ids
       * @description Pipeline runs linked to the model version
       * @default {}
       */
      pipeline_run_ids?: {
        [key: string]: unknown;
      };
      /**
       * Tags associated with the model version
       * @default []
       */
      tags?: components["schemas"]["TagResponse"][];
    };
    /**
     * ModelVersionResponseMetadata
     * @description Response metadata for model versions.
     */
    ModelVersionResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /**
       * Description
       * @description The description of the model version
       */
      description?: string;
      /**
       * Run Metadata
       * @description Metadata linked to the model version
       * @default {}
       */
      run_metadata?: {
        [key: string]: unknown;
      };
    };
    /**
     * ModelVersionUpdate
     * @description Update model for model versions.
     */
    ModelVersionUpdate: {
      /**
       * Model
       * Format: uuid
       * @description The ID of the model containing version
       */
      model: string;
      /**
       * Stage
       * @description Target model version stage to be set
       */
      stage?: string | components["schemas"]["ModelStages"];
      /**
       * Force
       * @description Whether existing model version in target stage should be silently archived or an error should be raised.
       * @default false
       */
      force?: boolean;
      /**
       * Name
       * @description Target model version name to be set
       */
      name?: string;
      /**
       * Add Tags
       * @description Tags to be added to the model version
       */
      add_tags?: string[];
      /**
       * Remove Tags
       * @description Tags to be removed from the model version
       */
      remove_tags?: string[];
    };
    /**
     * OAuthDeviceAuthorizationResponse
     * @description OAuth2 device authorization grant response.
     */
    OAuthDeviceAuthorizationResponse: {
      /** Device Code */
      device_code: string;
      /** User Code */
      user_code: string;
      /** Verification Uri */
      verification_uri: string;
      /** Verification Uri Complete */
      verification_uri_complete?: string;
      /** Expires In */
      expires_in: number;
      /** Interval */
      interval: number;
    };
    /**
     * OAuthDeviceResponse
     * @description Response model for OAuth2 devices.
     */
    OAuthDeviceResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["OAuthDeviceResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["OAuthDeviceResponseMetadata"];
    };
    /**
     * OAuthDeviceResponseBody
     * @description Response body for OAuth2 devices.
     */
    OAuthDeviceResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /**
       * Client Id
       * Format: uuid
       * @description The client ID of the OAuth2 device.
       */
      client_id: string;
      /**
       * Expires
       * Format: date-time
       * @description The expiration date of the OAuth2 device after which the device is no longer valid and cannot be used for authentication.
       */
      expires?: string;
      /**
       * Trusted Device
       * @description Whether the OAuth2 device was marked as trusted. A trusted device has a much longer validity time.
       */
      trusted_device: boolean;
      /** @description The status of the OAuth2 device. */
      status: components["schemas"]["OAuthDeviceStatus"];
      /**
       * Os
       * @description The operating system of the device used for authentication.
       */
      os?: string;
      /**
       * Ip Address
       * @description The IP address of the device used for authentication.
       */
      ip_address?: string;
      /**
       * Hostname
       * @description The hostname of the device used for authentication.
       */
      hostname?: string;
    };
    /**
     * OAuthDeviceResponseMetadata
     * @description Response metadata for OAuth2 devices.
     */
    OAuthDeviceResponseMetadata: {
      /**
       * Python Version
       * @description The Python version of the device used for authentication.
       */
      python_version?: string;
      /**
       * Zenml Version
       * @description The ZenML version of the device used for authentication.
       */
      zenml_version?: string;
      /**
       * City
       * @description The city where the device is located.
       */
      city?: string;
      /**
       * Region
       * @description The region where the device is located.
       */
      region?: string;
      /**
       * Country
       * @description The country where the device is located.
       */
      country?: string;
      /**
       * Failed Auth Attempts
       * @description The number of failed authentication attempts.
       */
      failed_auth_attempts: number;
      /**
       * Last Login
       * Format: date-time
       * @description The date of the last successful login.
       */
      last_login?: string;
    };
    /**
     * OAuthDeviceStatus
     * @description The OAuth device status.
     * @enum {string}
     */
    OAuthDeviceStatus: "pending" | "verified" | "active" | "locked";
    /**
     * OAuthDeviceUpdate
     * @description OAuth2 device update model.
     */
    OAuthDeviceUpdate: {
      /**
       * Locked
       * @description Whether to lock or unlock the OAuth2 device. A locked device cannot be used for authentication.
       */
      locked?: boolean;
    };
    /**
     * OAuthDeviceVerificationRequest
     * @description OAuth2 device authorization verification request.
     */
    OAuthDeviceVerificationRequest: {
      /** User Code */
      user_code: string;
      /**
       * Trusted Device
       * @default false
       */
      trusted_device?: boolean;
    };
    /**
     * OAuthRedirectResponse
     * @description Redirect response.
     */
    OAuthRedirectResponse: {
      /** Authorization Url */
      authorization_url: string;
    };
    /**
     * OAuthTokenResponse
     * @description OAuth2 device authorization token response.
     */
    OAuthTokenResponse: {
      /** Access Token */
      access_token: string;
      /** Token Type */
      token_type: string;
      /** Expires In */
      expires_in?: number;
      /** Refresh Token */
      refresh_token?: string;
      /** Scope */
      scope?: string;
    };
    /**
     * Page[APIKeyResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_APIKeyResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["APIKeyResponse"][];
    };
    /**
     * Page[ArtifactResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_ArtifactResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["ArtifactResponse"][];
    };
    /**
     * Page[ArtifactVersionResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_ArtifactVersionResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["ArtifactVersionResponse"][];
    };
    /**
     * Page[CodeRepositoryResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_CodeRepositoryResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["CodeRepositoryResponse"][];
    };
    /**
     * Page[ComponentResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_ComponentResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["ComponentResponse"][];
    };
    /**
     * Page[FlavorResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_FlavorResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["FlavorResponse"][];
    };
    /**
     * Page[ModelResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_ModelResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["ModelResponse"][];
    };
    /**
     * Page[ModelVersionArtifactResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_ModelVersionArtifactResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["ModelVersionArtifactResponse"][];
    };
    /**
     * Page[ModelVersionPipelineRunResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_ModelVersionPipelineRunResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["ModelVersionPipelineRunResponse"][];
    };
    /**
     * Page[ModelVersionResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_ModelVersionResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["ModelVersionResponse"][];
    };
    /**
     * Page[OAuthDeviceResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_OAuthDeviceResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["OAuthDeviceResponse"][];
    };
    /**
     * Page[PipelineBuildResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_PipelineBuildResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["PipelineBuildResponse"][];
    };
    /**
     * Page[PipelineDeploymentResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_PipelineDeploymentResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["PipelineDeploymentResponse"][];
    };
    /**
     * Page[PipelineResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_PipelineResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["PipelineResponse"][];
    };
    /**
     * Page[PipelineRunResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_PipelineRunResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["PipelineRunResponse"][];
    };
    /**
     * Page[RunMetadataResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_RunMetadataResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["RunMetadataResponse"][];
    };
    /**
     * Page[ScheduleResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_ScheduleResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["ScheduleResponse"][];
    };
    /**
     * Page[SecretResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_SecretResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["SecretResponse"][];
    };
    /**
     * Page[ServiceAccountResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_ServiceAccountResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["ServiceAccountResponse"][];
    };
    /**
     * Page[ServiceConnectorResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_ServiceConnectorResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["ServiceConnectorResponse"][];
    };
    /**
     * Page[StackResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_StackResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["StackResponse"][];
    };
    /**
     * Page[StepRunResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_StepRunResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["StepRunResponse"][];
    };
    /**
     * Page[TagResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_TagResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["TagResponse"][];
    };
    /**
     * Page[UserResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_UserResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["UserResponse"][];
    };
    /**
     * Page[WorkspaceResponse]
     * @description Return Model for List Models to accommodate pagination.
     */
    Page_WorkspaceResponse_: {
      /** Index */
      index: number;
      /** Max Size */
      max_size: number;
      /** Total Pages */
      total_pages: number;
      /** Total */
      total: number;
      /** Items */
      items: components["schemas"]["WorkspaceResponse"][];
    };
    /**
     * PipelineBuildRequest
     * @description Request model for pipelines builds.
     */
    PipelineBuildRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /**
       * The images of this build.
       * @default {}
       */
      images?: {
        [key: string]: unknown;
      };
      /** Whether the build images are stored in a container registry or locally. */
      is_local: boolean;
      /** Whether any image of the build contains user code. */
      contains_code: boolean;
      /** The version of ZenML used for this build. */
      zenml_version?: string;
      /** The Python version used for this build. */
      python_version?: string;
      /** The build checksum. */
      checksum?: string;
      /**
       * The stack that was used for this build.
       * Format: uuid
       */
      stack?: string;
      /**
       * The pipeline that was used for this build.
       * Format: uuid
       */
      pipeline?: string;
    };
    /**
     * PipelineBuildResponse
     * @description Response model for pipeline builds.
     */
    PipelineBuildResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["PipelineBuildResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["PipelineBuildResponseMetadata"];
    };
    /**
     * PipelineBuildResponseBody
     * @description Response body for pipeline builds.
     */
    PipelineBuildResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
    };
    /**
     * PipelineBuildResponseMetadata
     * @description Response metadata for pipeline builds.
     */
    PipelineBuildResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /** The pipeline that was used for this build. */
      pipeline?: components["schemas"]["PipelineResponse"];
      /** The stack that was used for this build. */
      stack?: components["schemas"]["StackResponse"];
      /**
       * The images of this build.
       * @default {}
       */
      images?: {
        [key: string]: unknown;
      };
      /** The version of ZenML used for this build. */
      zenml_version?: string;
      /** The Python version used for this build. */
      python_version?: string;
      /** The build checksum. */
      checksum?: string;
      /** Whether the build images are stored in a container registry or locally. */
      is_local: boolean;
      /** Whether any image of the build contains user code. */
      contains_code: boolean;
    };
    /**
     * PipelineConfiguration
     * @description Pipeline configuration class.
     */
    PipelineConfiguration: {
      /** Enable Cache */
      enable_cache?: boolean;
      /** Enable Artifact Metadata */
      enable_artifact_metadata?: boolean;
      /** Enable Artifact Visualization */
      enable_artifact_visualization?: boolean;
      /** Enable Step Logs */
      enable_step_logs?: boolean;
      /**
       * Settings
       * @default {}
       */
      settings?: {
        [key: string]: unknown;
      };
      /**
       * Extra
       * @default {}
       */
      extra?: {
        [key: string]: unknown;
      };
      failure_hook_source?: components["schemas"]["Source"];
      success_hook_source?: components["schemas"]["Source"];
      model_version?: components["schemas"]["ModelVersion"];
      /** Parameters */
      parameters?: {
        [key: string]: unknown;
      };
      /** Name */
      name: string;
    };
    /**
     * PipelineDeploymentRequest
     * @description Request model for pipeline deployments.
     */
    PipelineDeploymentRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /** The run name template for runs created using this deployment. */
      run_name_template: string;
      /** The pipeline configuration for this deployment. */
      pipeline_configuration: components["schemas"]["PipelineConfiguration"];
      /**
       * The step configurations for this deployment.
       * @default {}
       */
      step_configurations?: {
        [key: string]: unknown;
      };
      /**
       * The client environment for this deployment.
       * @default {}
       */
      client_environment?: {
        [key: string]: unknown;
      };
      /** The version of the ZenML installation on the client side. */
      client_version?: string;
      /** The version of the ZenML installation on the server side. */
      server_version?: string;
      /**
       * The stack associated with the deployment.
       * Format: uuid
       */
      stack: string;
      /**
       * The pipeline associated with the deployment.
       * Format: uuid
       */
      pipeline?: string;
      /**
       * The build associated with the deployment.
       * Format: uuid
       */
      build?: string;
      /**
       * The schedule associated with the deployment.
       * Format: uuid
       */
      schedule?: string;
      /** The code reference associated with the deployment. */
      code_reference?: components["schemas"]["CodeReferenceRequest"];
    };
    /**
     * PipelineDeploymentResponse
     * @description Response model for pipeline deployments.
     */
    PipelineDeploymentResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["PipelineDeploymentResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["PipelineDeploymentResponseMetadata"];
    };
    /**
     * PipelineDeploymentResponseBody
     * @description Response body for pipeline deployments.
     */
    PipelineDeploymentResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
    };
    /**
     * PipelineDeploymentResponseMetadata
     * @description Response metadata for pipeline deployments.
     */
    PipelineDeploymentResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /** The run name template for runs created using this deployment. */
      run_name_template: string;
      /** The pipeline configuration for this deployment. */
      pipeline_configuration: components["schemas"]["PipelineConfiguration"];
      /**
       * The step configurations for this deployment.
       * @default {}
       */
      step_configurations?: {
        [key: string]: unknown;
      };
      /**
       * The client environment for this deployment.
       * @default {}
       */
      client_environment?: {
        [key: string]: unknown;
      };
      /** The version of the ZenML installation on the client side. */
      client_version?: string;
      /** The version of the ZenML installation on the server side. */
      server_version?: string;
      /** The pipeline associated with the deployment. */
      pipeline?: components["schemas"]["PipelineResponse"];
      /** The stack associated with the deployment. */
      stack?: components["schemas"]["StackResponse"];
      /** The pipeline build associated with the deployment. */
      build?: components["schemas"]["PipelineBuildResponse"];
      /** The schedule associated with the deployment. */
      schedule?: components["schemas"]["ScheduleResponse"];
      /** The code reference associated with the deployment. */
      code_reference?: components["schemas"]["CodeReferenceResponse"];
    };
    /**
     * PipelineRequest
     * @description Request model for pipelines.
     */
    PipelineRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /** The name of the pipeline. */
      name: string;
      /** The version of the pipeline. */
      version: string;
      /** The version hash of the pipeline. */
      version_hash: string;
      /** The docstring of the pipeline. */
      docstring?: string;
      /** The spec of the pipeline. */
      spec: components["schemas"]["PipelineSpec"];
    };
    /**
     * PipelineResponse
     * @description Response model for pipelines.
     */
    PipelineResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["PipelineResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["PipelineResponseMetadata"];
      /** The name of the pipeline. */
      name: string;
    };
    /**
     * PipelineResponseBody
     * @description Response body for pipelines.
     */
    PipelineResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /** The status of the last 3 Pipeline Runs. */
      status?: components["schemas"]["ExecutionStatus"][];
      /** The version of the pipeline. */
      version: string;
    };
    /**
     * PipelineResponseMetadata
     * @description Response metadata for pipelines.
     */
    PipelineResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /** The version hash of the pipeline. */
      version_hash: string;
      /** The spec of the pipeline. */
      spec: components["schemas"]["PipelineSpec"];
      /** The docstring of the pipeline. */
      docstring?: string;
    };
    /**
     * PipelineRunRequest
     * @description Request model for pipeline runs.
     */
    PipelineRunRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /**
       * Id
       * Format: uuid
       */
      id: string;
      /** The name of the pipeline run. */
      name: string;
      /**
       * The deployment associated with the pipeline run.
       * Format: uuid
       */
      deployment: string;
      /**
       * The pipeline associated with the pipeline run.
       * Format: uuid
       */
      pipeline?: string;
      /** The orchestrator run ID. */
      orchestrator_run_id?: string;
      /**
       * The start time of the pipeline run.
       * Format: date-time
       */
      start_time?: string;
      /**
       * The end time of the pipeline run.
       * Format: date-time
       */
      end_time?: string;
      /** The status of the pipeline run. */
      status: components["schemas"]["ExecutionStatus"];
      /**
       * Environment of the client that initiated this pipeline run (OS, Python version, etc.).
       * @default {}
       */
      client_environment?: {
        [key: string]: unknown;
      };
      /**
       * Environment of the orchestrator that executed this pipeline run (OS, Python version, etc.).
       * @default {}
       */
      orchestrator_environment?: {
        [key: string]: unknown;
      };
    };
    /**
     * PipelineRunResponse
     * @description Response model for pipeline runs.
     */
    PipelineRunResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["PipelineRunResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["PipelineRunResponseMetadata"];
      /** The name of the pipeline run. */
      name: string;
    };
    /**
     * PipelineRunResponseBody
     * @description Response body for pipeline runs.
     */
    PipelineRunResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /** The status of the pipeline run. */
      status: components["schemas"]["ExecutionStatus"];
      /** The stack that was used for this run. */
      stack?: components["schemas"]["StackResponse"];
      /** The pipeline this run belongs to. */
      pipeline?: components["schemas"]["PipelineResponse"];
      /** The pipeline build that was used for this run. */
      build?: components["schemas"]["PipelineBuildResponse"];
      /** The schedule that was used for this run. */
      schedule?: components["schemas"]["ScheduleResponse"];
      /** The code reference that was used for this run. */
      code_reference?: components["schemas"]["CodeReferenceResponse"];
    };
    /**
     * PipelineRunResponseMetadata
     * @description Response metadata for pipeline runs.
     */
    PipelineRunResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /**
       * Metadata associated with this pipeline run.
       * @default {}
       */
      run_metadata?: {
        [key: string]: unknown;
      };
      /**
       * The steps of this run.
       * @default {}
       */
      steps?: {
        [key: string]: unknown;
      };
      /** The pipeline configuration used for this pipeline run. */
      config: components["schemas"]["PipelineConfiguration"];
      /**
       * The start time of the pipeline run.
       * Format: date-time
       */
      start_time?: string;
      /**
       * The end time of the pipeline run.
       * Format: date-time
       */
      end_time?: string;
      /**
       * Environment of the client that initiated this pipeline run (OS, Python version, etc.).
       * @default {}
       */
      client_environment?: {
        [key: string]: unknown;
      };
      /**
       * Environment of the orchestrator that executed this pipeline run (OS, Python version, etc.).
       * @default {}
       */
      orchestrator_environment?: {
        [key: string]: unknown;
      };
      /** The orchestrator run ID. */
      orchestrator_run_id?: string;
    };
    /**
     * PipelineRunUpdate
     * @description Pipeline run update model.
     */
    PipelineRunUpdate: {
      status?: components["schemas"]["ExecutionStatus"];
      /**
       * End Time
       * Format: date-time
       */
      end_time?: string;
    };
    /**
     * PipelineSpec
     * @description Specification of a pipeline.
     */
    PipelineSpec: {
      /**
       * Version
       * @default 0.4
       */
      version?: string;
      source?: components["schemas"]["Source"];
      /**
       * Parameters
       * @default {}
       */
      parameters?: {
        [key: string]: unknown;
      };
      /** Steps */
      steps: components["schemas"]["StepSpec"][];
    };
    /**
     * PipelineUpdate
     * @description Update model for pipelines.
     */
    PipelineUpdate: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user?: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace?: string;
      /** The name of the pipeline. */
      name?: string;
      /** The version of the pipeline. */
      version?: string;
      /** The version hash of the pipeline. */
      version_hash?: string;
      /** The docstring of the pipeline. */
      docstring?: string;
      /** The spec of the pipeline. */
      spec?: components["schemas"]["PipelineSpec"];
    };
    /**
     * ResourceTypeModel
     * @description Resource type specification.
     *
     * Describes the authentication methods and resource instantiation model for
     * one or more resource types.
     */
    ResourceTypeModel: {
      /** User readable name for the resource type. */
      name: string;
      /** Resource type identifier. */
      resource_type: string;
      /**
       * A description of the resource type.
       * @default
       */
      description?: string;
      /** The list of authentication methods that can be used to access resources of this type. */
      auth_methods: string[];
      /**
       * Specifies if a single connector instance can be used to access multiple instances of this resource type. If set to True, the connector is able to provide a list of resource IDs identifying all the resources that it can access and a resource ID needs to be explicitly configured or supplied when access to a resource is requested. If set to False, a connector instance is only able to access a single resource and a resource ID is not required to access the resource.
       * @default false
       */
      supports_instances?: boolean;
      /** Optionally, a URL pointing to a png,svg or jpg file can be attached. */
      logo_url?: string;
      /** Optionally, a python-rich emoji can be attached. */
      emoji?: string;
    };
    /**
     * RunMetadataRequest
     * @description Request model for run metadata.
     */
    RunMetadataRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /**
       * The ID of the resource that this metadata belongs to.
       * Format: uuid
       */
      resource_id: string;
      /** The type of the resource that this metadata belongs to. */
      resource_type: components["schemas"]["MetadataResourceTypes"];
      /**
       * The ID of the stack component that this metadata belongs to.
       * Format: uuid
       */
      stack_component_id?: string;
      /** The metadata to be created. */
      values: {
        [key: string]: unknown;
      };
      /** The types of the metadata to be created. */
      types: {
        [key: string]: unknown;
      };
    };
    /**
     * RunMetadataResponse
     * @description Response model for run metadata.
     */
    RunMetadataResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["RunMetadataResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["RunMetadataResponseMetadata"];
    };
    /**
     * RunMetadataResponseBody
     * @description Response body for run metadata.
     */
    RunMetadataResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /** The key of the metadata. */
      key: string;
      /** The value of the metadata. */
      value: string | number | boolean | {
        [key: string]: unknown;
      } | unknown[];
      /** The type of the metadata. */
      type: string;
    };
    /**
     * RunMetadataResponseMetadata
     * @description Response metadata for run metadata.
     */
    RunMetadataResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /**
       * The ID of the resource that this metadata belongs to.
       * Format: uuid
       */
      resource_id: string;
      /** The type of the resource that this metadata belongs to. */
      resource_type: components["schemas"]["MetadataResourceTypes"];
      /**
       * The ID of the stack component that this metadata belongs to.
       * Format: uuid
       */
      stack_component_id?: string;
    };
    /**
     * ScheduleRequest
     * @description Request model for schedules.
     */
    ScheduleRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /** Name */
      name: string;
      /** Active */
      active: boolean;
      /** Cron Expression */
      cron_expression?: string;
      /**
       * Start Time
       * Format: date-time
       */
      start_time?: string;
      /**
       * End Time
       * Format: date-time
       */
      end_time?: string;
      /**
       * Interval Second
       * Format: time-delta
       */
      interval_second?: number;
      /**
       * Catchup
       * @default false
       */
      catchup?: boolean;
      /**
       * Orchestrator Id
       * Format: uuid
       */
      orchestrator_id?: string;
      /**
       * Pipeline Id
       * Format: uuid
       */
      pipeline_id?: string;
    };
    /**
     * ScheduleResponse
     * @description Response model for schedules.
     */
    ScheduleResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["ScheduleResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["ScheduleResponseMetadata"];
      /** Name of this schedule. */
      name: string;
    };
    /**
     * ScheduleResponseBody
     * @description Response body for schedules.
     */
    ScheduleResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /** Active */
      active: boolean;
      /** Cron Expression */
      cron_expression?: string;
      /**
       * Start Time
       * Format: date-time
       */
      start_time?: string;
      /**
       * End Time
       * Format: date-time
       */
      end_time?: string;
      /**
       * Interval Second
       * Format: time-delta
       */
      interval_second?: number;
      /**
       * Catchup
       * @default false
       */
      catchup?: boolean;
    };
    /**
     * ScheduleResponseMetadata
     * @description Response metadata for schedules.
     */
    ScheduleResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /**
       * Orchestrator Id
       * Format: uuid
       */
      orchestrator_id?: string;
      /**
       * Pipeline Id
       * Format: uuid
       */
      pipeline_id?: string;
    };
    /**
     * ScheduleUpdate
     * @description Update model for schedules.
     */
    ScheduleUpdate: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user?: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace?: string;
      /** Name */
      name?: string;
      /** Active */
      active?: boolean;
      /** Cron Expression */
      cron_expression?: string;
      /**
       * Start Time
       * Format: date-time
       */
      start_time?: string;
      /**
       * End Time
       * Format: date-time
       */
      end_time?: string;
      /**
       * Interval Second
       * Format: time-delta
       */
      interval_second?: number;
      /**
       * Catchup
       * @default false
       */
      catchup?: boolean;
      /**
       * Orchestrator Id
       * Format: uuid
       */
      orchestrator_id?: string;
      /**
       * Pipeline Id
       * Format: uuid
       */
      pipeline_id?: string;
    };
    /**
     * SecretRequest
     * @description Request models for secrets.
     */
    SecretRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /** The name of the secret. */
      name: string;
      /**
       * The scope of the secret.
       * @default workspace
       */
      scope?: components["schemas"]["SecretScope"];
      /** The values stored in this secret. */
      values?: {
        [key: string]: unknown;
      };
    };
    /**
     * SecretResponse
     * @description Response model for secrets.
     */
    SecretResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["SecretResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["SecretResponseMetadata"];
      /** The name of the secret. */
      name: string;
    };
    /**
     * SecretResponseBody
     * @description Response body for secrets.
     */
    SecretResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /**
       * The scope of the secret.
       * @default workspace
       */
      scope?: components["schemas"]["SecretScope"];
      /** The values stored in this secret. */
      values?: {
        [key: string]: unknown;
      };
    };
    /**
     * SecretResponseMetadata
     * @description Response metadata for secrets.
     */
    SecretResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
    };
    /**
     * SecretScope
     * @description Enum for the scope of a secret.
     * @enum {string}
     */
    SecretScope: "workspace" | "user";
    /**
     * SecretUpdate
     * @description Secret update model.
     */
    SecretUpdate: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user?: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace?: string;
      /** The name of the secret. */
      name?: string;
      /** The scope of the secret. */
      scope?: components["schemas"]["SecretScope"];
      /** The values stored in this secret. */
      values?: {
        [key: string]: unknown;
      };
    };
    /**
     * SecretsStoreType
     * @description Secrets Store Backend Types.
     *
     * NOTE: this is a superset of the StoreType values because the set of secrets
     * store backends includes all the backends supported for zen stores.
     * @enum {string}
     */
    SecretsStoreType: "none" | "sql" | "rest" | "aws" | "gcp" | "azure" | "hashicorp" | "custom";
    /**
     * ServerDatabaseType
     * @description Enum for server database types.
     * @enum {string}
     */
    ServerDatabaseType: "sqlite" | "mysql" | "other";
    /**
     * ServerDeploymentType
     * @description Enum for server deployment types.
     * @enum {string}
     */
    ServerDeploymentType: "local" | "docker" | "kubernetes" | "aws" | "gcp" | "azure" | "alpha" | "other" | "hf_spaces" | "sandbox" | "cloud";
    /**
     * ServerModel
     * @description Domain model for ZenML servers.
     */
    ServerModel: {
      /**
       * The unique server id.
       * Format: uuid
       */
      id?: string;
      /** The ZenML version that the server is running. */
      version: string;
      /**
       * Flag to indicate whether ZenML is running on debug mode.
       * @default false
       */
      debug?: boolean;
      /**
       * The ZenML server deployment type.
       * @default other
       */
      deployment_type?: components["schemas"]["ServerDeploymentType"];
      /**
       * The database type that the server is using.
       * @default other
       */
      database_type?: components["schemas"]["ServerDatabaseType"];
      /**
       * The type of secrets store that the server is using.
       * @default none
       */
      secrets_store_type?: components["schemas"]["SecretsStoreType"];
      /** The authentication scheme that the server is using. */
      auth_scheme: components["schemas"]["AuthScheme"];
    };
    /**
     * ServiceAccountRequest
     * @description Request model for service accounts.
     */
    ServiceAccountRequest: {
      /** The unique name for the service account. */
      name: string;
      /** A description of the service account. */
      description?: string;
      /** Whether the service account is active or not. */
      active: boolean;
    };
    /**
     * ServiceAccountResponse
     * @description Response model for service accounts.
     */
    ServiceAccountResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["ServiceAccountResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["ServiceAccountResponseMetadata"];
      /** The unique username for the account. */
      name: string;
    };
    /**
     * ServiceAccountResponseBody
     * @description Response body for service accounts.
     */
    ServiceAccountResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /**
       * Whether the account is active.
       * @default false
       */
      active?: boolean;
    };
    /**
     * ServiceAccountResponseMetadata
     * @description Response metadata for service accounts.
     */
    ServiceAccountResponseMetadata: {
      /**
       * A description of the service account.
       * @default
       */
      description?: string;
    };
    /**
     * ServiceAccountUpdate
     * @description Update model for service accounts.
     */
    ServiceAccountUpdate: {
      /** The unique name for the service account. */
      name?: string;
      /** A description of the service account. */
      description?: string;
      /** Whether the service account is active or not. */
      active?: boolean;
    };
    /**
     * ServiceConnectorRequest
     * @description Request model for service connectors.
     */
    ServiceConnectorRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /** The service connector name. */
      name: string;
      /** The type of service connector. */
      connector_type: string | components["schemas"]["ServiceConnectorTypeModel"];
      /**
       * The service connector instance description.
       * @default
       */
      description?: string;
      /** The authentication method that the connector instance uses to access the resources. */
      auth_method: string;
      /** The type(s) of resource that the connector instance can be used to gain access to. */
      resource_types?: string[];
      /** Uniquely identifies a specific resource instance that the connector instance can be used to access. If omitted, the connector instance can be used to access any and all resource instances that the authentication method and resource type(s) allow. */
      resource_id?: string;
      /**
       * Indicates whether the connector instance can be used to access multiple instances of the configured resource type.
       * @default false
       */
      supports_instances?: boolean;
      /**
       * Time when the authentication credentials configured for the connector expire. If omitted, the credentials do not expire.
       * Format: date-time
       */
      expires_at?: string;
      /** The number of seconds of tolerance to apply when checking whether the authentication credentials configured for the connector have expired. If omitted, no tolerance is applied. */
      expires_skew_tolerance?: number;
      /** The duration, in seconds, that the temporary credentials generated by this connector should remain valid. Only applicable for connectors and authentication methods that involve generating temporary credentials from the ones configured in the connector. */
      expiration_seconds?: number;
      /** The service connector configuration, not including secrets. */
      configuration?: {
        [key: string]: unknown;
      };
      /** The service connector secrets. */
      secrets?: {
        [key: string]: unknown;
      };
      /** Service connector labels. */
      labels?: {
        [key: string]: unknown;
      };
    };
    /**
     * ServiceConnectorResourcesModel
     * @description Service connector resources list.
     *
     * Lists the resource types and resource instances that a service connector
     * can provide access to.
     */
    ServiceConnectorResourcesModel: {
      /**
       * The ID of the service connector instance providing this resource.
       * Format: uuid
       */
      id?: string;
      /** The name of the service connector instance providing this resource. */
      name?: string;
      /** The type of service connector. */
      connector_type: string | components["schemas"]["ServiceConnectorTypeModel"];
      /** The list of resources that the service connector instance can give access to. Contains one entry for every resource type that the connector is configured for. */
      resources?: components["schemas"]["ServiceConnectorTypedResourcesModel"][];
      /** A global error message describing why the service connector instance could not authenticate to the remote service. */
      error?: string;
    };
    /**
     * ServiceConnectorResponse
     * @description Response model for service connectors.
     */
    ServiceConnectorResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["ServiceConnectorResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["ServiceConnectorResponseMetadata"];
      /** The service connector name. */
      name: string;
    };
    /**
     * ServiceConnectorResponseBody
     * @description Response body for service connectors.
     */
    ServiceConnectorResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /**
       * The service connector instance description.
       * @default
       */
      description?: string;
      /** The type of service connector. */
      connector_type: string | components["schemas"]["ServiceConnectorTypeModel"];
      /** The authentication method that the connector instance uses to access the resources. */
      auth_method: string;
      /** The type(s) of resource that the connector instance can be used to gain access to. */
      resource_types?: string[];
      /** Uniquely identifies a specific resource instance that the connector instance can be used to access. If omitted, the connector instance can be used to access any and all resource instances that the authentication method and resource type(s) allow. */
      resource_id?: string;
      /**
       * Indicates whether the connector instance can be used to access multiple instances of the configured resource type.
       * @default false
       */
      supports_instances?: boolean;
      /**
       * Time when the authentication credentials configured for the connector expire. If omitted, the credentials do not expire.
       * Format: date-time
       */
      expires_at?: string;
      /** The number of seconds of tolerance to apply when checking whether the authentication credentials configured for the connector have expired. If omitted, no tolerance is applied. */
      expires_skew_tolerance?: number;
    };
    /**
     * ServiceConnectorResponseMetadata
     * @description Response metadata for service connectors.
     */
    ServiceConnectorResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /** The service connector configuration, not including secrets. */
      configuration?: {
        [key: string]: unknown;
      };
      /**
       * The ID of the secret that contains the service connector secret configuration values.
       * Format: uuid
       */
      secret_id?: string;
      /** The duration, in seconds, that the temporary credentials generated by this connector should remain valid. Only applicable for connectors and authentication methods that involve generating temporary credentials from the ones configured in the connector. */
      expiration_seconds?: number;
      /** The service connector secrets. */
      secrets?: {
        [key: string]: unknown;
      };
      /** Service connector labels. */
      labels?: {
        [key: string]: unknown;
      };
    };
    /**
     * ServiceConnectorTypeModel
     * @description Service connector type specification.
     *
     * Describes the types of resources to which the service connector can be used
     * to gain access and the authentication methods that are supported by the
     * service connector.
     *
     * The connector type, resource types, resource IDs and authentication
     * methods can all be used as search criteria to lookup and filter service
     * connector instances that are compatible with the requirements of a consumer
     * (e.g. a stack component).
     */
    ServiceConnectorTypeModel: {
      /** User readable name for the service connector type. */
      name: string;
      /** The type of service connector. It can be used to represent a generic resource (e.g. Docker, Kubernetes) or a group of different resources accessible through a common interface or point of access and authentication (e.g. a cloud provider or a platform). */
      connector_type: string;
      /**
       * A description of the service connector.
       * @default
       */
      description?: string;
      /** A list of resource types that the connector can be used to access. */
      resource_types: components["schemas"]["ResourceTypeModel"][];
      /** A list of specifications describing the authentication methods that are supported by the service connector, along with the configuration and secrets attributes that need to be configured for them. */
      auth_methods: components["schemas"]["AuthenticationMethodModel"][];
      /**
       * Models if the connector can be configured automatically based on information extracted from a local environment.
       * @default false
       */
      supports_auto_configuration?: boolean;
      /** Optionally, a URL pointing to a png,svg or jpg can be attached. */
      logo_url?: string;
      /** Optionally, a python-rich emoji can be attached. */
      emoji?: string;
      /** Optionally, a URL pointing to docs, within docs.zenml.io. */
      docs_url?: string;
      /** Optionally, a URL pointing to SDK docs,within sdkdocs.zenml.io. */
      sdk_docs_url?: string;
      /**
       * If True, the service connector is available locally.
       * @default true
       */
      local?: boolean;
      /**
       * If True, the service connector is available remotely.
       * @default false
       */
      remote?: boolean;
    };
    /**
     * ServiceConnectorTypedResourcesModel
     * @description Service connector typed resources list.
     *
     * Lists the resource instances that a service connector can provide
     * access to.
     */
    ServiceConnectorTypedResourcesModel: {
      /** The type of resource that the service connector instance can be used to access. */
      resource_type: string;
      /** The resource IDs of all resource instances that the service connector instance can be used to access. Omitted (set to None) for multi-type service connectors that didn't explicitly request to fetch resources for all resource types. Also omitted if an error occurred while listing the resource instances or if no resources are listed due to authorization issues or lack of permissions (in both cases the 'error' field is set to an error message). For resource types that do not support multiple instances, a single resource ID is listed. */
      resource_ids?: string[];
      /** An error message describing why the service connector instance could not list the resources that it is configured to access. */
      error?: string;
    };
    /**
     * ServiceConnectorUpdate
     * @description Model used for service connector updates.
     *
     * Most fields in the update model are optional and will not be updated if
     * omitted. However, the following fields are "special" and leaving them out
     * will also cause the corresponding value to be removed from the service
     * connector in the database:
     *
     * * the `resource_id` field
     * * the `expiration_seconds` field
     *
     * In addition to the above exceptions, the following rules apply:
     *
     * * the `configuration` and `secrets` fields together represent a full
     * valid configuration update, not just a partial update. If either is
     * set (i.e. not None) in the update, their values are merged together and
     * will replace the existing configuration and secrets values.
     * * the `secret_id` field value in the update is ignored, given that
     * secrets are managed internally by the ZenML store.
     * * the `labels` field is also a full labels update: if set (i.e. not
     * `None`), all existing labels are removed and replaced by the new labels
     * in the update.
     *
     * NOTE: the attributes here override the ones in the base class, so they
     * have a None default value.
     */
    ServiceConnectorUpdate: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user?: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace?: string;
      /** The service connector name. */
      name?: string;
      /** The type of service connector. */
      connector_type?: string | components["schemas"]["ServiceConnectorTypeModel"];
      /**
       * The service connector instance description.
       * @default
       */
      description?: string;
      /** The authentication method that the connector instance uses to access the resources. */
      auth_method?: string;
      /** The type(s) of resource that the connector instance can be used to gain access to. */
      resource_types?: string[];
      /** Uniquely identifies a specific resource instance that the connector instance can be used to access. If omitted, the connector instance can be used to access any and all resource instances that the authentication method and resource type(s) allow. */
      resource_id?: string;
      /**
       * Indicates whether the connector instance can be used to access multiple instances of the configured resource type.
       * @default false
       */
      supports_instances?: boolean;
      /**
       * Time when the authentication credentials configured for the connector expire. If omitted, the credentials do not expire.
       * Format: date-time
       */
      expires_at?: string;
      /** The number of seconds of tolerance to apply when checking whether the authentication credentials configured for the connector have expired. If omitted, no tolerance is applied. */
      expires_skew_tolerance?: number;
      /** The duration, in seconds, that the temporary credentials generated by this connector should remain valid. Only applicable for connectors and authentication methods that involve generating temporary credentials from the ones configured in the connector. */
      expiration_seconds?: number;
      /** The service connector configuration, not including secrets. */
      configuration?: {
        [key: string]: unknown;
      };
      /** The service connector secrets. */
      secrets?: {
        [key: string]: unknown;
      };
      /** Service connector labels. */
      labels?: {
        [key: string]: unknown;
      };
    };
    /**
     * Source
     * @description Source specification.
     *
     * A source specifies a module name as well as an optional attribute of that
     * module. These values can be used to import the module and get the value
     * of the attribute inside the module.
     *
     * Example:
     *     The source `Source(module="zenml.config.source", attribute="Source")`
     *     references the class that this docstring is describing. This class is
     *     defined in the `zenml.config.source` module and the name of the
     *     attribute is the class name `Source`.
     *
     * Attributes:
     *     module: The module name.
     *     attribute: Optional name of the attribute inside the module.
     *     type: The type of the source.
     */
    Source: {
      /** Module */
      module: string;
      /** Attribute */
      attribute?: string;
      type: components["schemas"]["SourceType"];
    };
    /**
     * SourceType
     * @description Enum representing different types of sources.
     * @enum {unknown}
     */
    SourceType: "user" | "builtin" | "internal" | "distribution_package" | "code_repository" | "unknown";
    /**
     * StackComponentType
     * @description All possible types a `StackComponent` can have.
     * @enum {string}
     */
    StackComponentType: "alerter" | "annotator" | "artifact_store" | "container_registry" | "data_validator" | "experiment_tracker" | "feature_store" | "image_builder" | "model_deployer" | "orchestrator" | "step_operator" | "model_registry";
    /**
     * StackRequest
     * @description Request model for stacks.
     */
    StackRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /** The name of the stack. */
      name: string;
      /**
       * The description of the stack
       * @default
       */
      description?: string;
      /** The path to the stack spec used for mlstacks deployments. */
      stack_spec_path?: string;
      /** A mapping of stack component types to the actualinstances of components of this type. */
      components?: {
        [key: string]: unknown;
      };
    };
    /**
     * StackResponse
     * @description Response model for stacks.
     */
    StackResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["StackResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["StackResponseMetadata"];
      /** The name of the stack. */
      name: string;
    };
    /**
     * StackResponseBody
     * @description Response body for stacks.
     */
    StackResponseBody: {
      /**
       * The timestamp when this component was created.
       * Format: date-time
       */
      created: string;
      /**
       * The timestamp when this component was last updated.
       * Format: date-time
       */
      updated: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
    };
    /**
     * StackResponseMetadata
     * @description Response metadata for stacks.
     */
    StackResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /** A mapping of stack component types to the actualinstances of components of this type. */
      components: {
        [key: string]: unknown;
      };
      /**
       * The description of the stack
       * @default
       */
      description?: string;
      /** The path to the stack spec used for mlstacks deployments. */
      stack_spec_path?: string;
    };
    /**
     * StackUpdate
     * @description Update model for stacks.
     */
    StackUpdate: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user?: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace?: string;
      /** The name of the stack. */
      name?: string;
      /**
       * The description of the stack
       * @default
       */
      description?: string;
      /** The path to the stack spec used for mlstacks deployments. */
      stack_spec_path?: string;
      /** A mapping of stack component types to the actualinstances of components of this type. */
      components?: {
        [key: string]: unknown;
      };
    };
    /**
     * Step
     * @description Class representing a ZenML step.
     */
    Step: {
      spec: components["schemas"]["StepSpec"];
      config: components["schemas"]["StepConfiguration"];
    };
    /**
     * StepConfiguration
     * @description Step configuration class.
     */
    StepConfiguration: {
      /** Name */
      name: string;
      /** Enable Cache */
      enable_cache?: boolean;
      /** Enable Artifact Metadata */
      enable_artifact_metadata?: boolean;
      /** Enable Artifact Visualization */
      enable_artifact_visualization?: boolean;
      /** Enable Step Logs */
      enable_step_logs?: boolean;
      /** Step Operator */
      step_operator?: string;
      /** Experiment Tracker */
      experiment_tracker?: string;
      /**
       * Parameters
       * @default {}
       */
      parameters?: {
        [key: string]: unknown;
      };
      /**
       * Settings
       * @default {}
       */
      settings?: {
        [key: string]: unknown;
      };
      /**
       * Extra
       * @default {}
       */
      extra?: {
        [key: string]: unknown;
      };
      failure_hook_source?: components["schemas"]["Source"];
      success_hook_source?: components["schemas"]["Source"];
      model_version?: components["schemas"]["ModelVersion"];
      /**
       * Outputs
       * @default {}
       */
      outputs?: {
        [key: string]: unknown;
      };
      /**
       * Caching Parameters
       * @default {}
       */
      caching_parameters?: {
        [key: string]: unknown;
      };
      /**
       * External Input Artifacts
       * @default {}
       */
      external_input_artifacts?: {
        [key: string]: unknown;
      };
    };
    /**
     * StepNode
     * @description A class that represents a step node in a lineage graph.
     */
    StepNode: {
      /** Id */
      id: string;
      /**
       * Type
       * @default step
       */
      type?: string;
      data: components["schemas"]["StepNodeDetails"];
    };
    /**
     * StepNodeDetails
     * @description Captures all artifact details for the node.
     */
    StepNodeDetails: {
      /** Execution Id */
      execution_id: string;
      /** Name */
      name: string;
      status: components["schemas"]["ExecutionStatus"];
      /** Entrypoint Name */
      entrypoint_name: string;
      /** Parameters */
      parameters: {
        [key: string]: unknown;
      };
      /** Configuration */
      configuration: {
        [key: string]: unknown;
      };
      /** Inputs */
      inputs: {
        [key: string]: unknown;
      };
      /** Outputs */
      outputs: {
        [key: string]: unknown;
      };
      /** Metadata */
      metadata: [string, string, string][];
    };
    /**
     * StepRunRequest
     * @description Request model for step runs.
     */
    StepRunRequest: {
      /**
       * The id of the user that created this resource.
       * Format: uuid
       */
      user: string;
      /**
       * The workspace to which this resource belongs.
       * Format: uuid
       */
      workspace: string;
      /** The name of the pipeline run step. */
      name: string;
      /**
       * The start time of the step run.
       * Format: date-time
       */
      start_time?: string;
      /**
       * The end time of the step run.
       * Format: date-time
       */
      end_time?: string;
      /** The status of the step. */
      status: components["schemas"]["ExecutionStatus"];
      /** The cache key of the step run. */
      cache_key?: string;
      /** The code hash of the step run. */
      code_hash?: string;
      /** The docstring of the step function or class. */
      docstring?: string;
      /** The source code of the step function or class. */
      source_code?: string;
      /**
       * The ID of the pipeline run that this step run belongs to.
       * Format: uuid
       */
      pipeline_run_id: string;
      /**
       * The ID of the original step run if this step was cached.
       * Format: uuid
       */
      original_step_run_id?: string;
      /** The IDs of the parent steps of this step run. */
      parent_step_ids?: string[];
      /**
       * The IDs of the input artifact versions of the step run.
       * @default {}
       */
      inputs?: {
        [key: string]: unknown;
      };
      /**
       * The IDs of the output artifact versions of the step run.
       * @default {}
       */
      outputs?: {
        [key: string]: unknown;
      };
      /** Logs associated with this step run. */
      logs?: components["schemas"]["LogsRequest"];
      /**
       * The deployment associated with the step run.
       * Format: uuid
       */
      deployment: string;
    };
    /**
     * StepRunResponse
     * @description Response model for step runs.
     */
    StepRunResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["StepRunResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["StepRunResponseMetadata"];
      /** The name of the pipeline run step. */
      name: string;
    };
    /**
     * StepRunResponseBody
     * @description Response body for step runs.
     */
    StepRunResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** The user who created this resource. */
      user?: components["schemas"]["UserResponse"];
      /** The status of the step. */
      status: components["schemas"]["ExecutionStatus"];
      /**
       * The input artifact versions of the step run.
       * @default {}
       */
      inputs?: {
        [key: string]: unknown;
      };
      /**
       * The output artifact versions of the step run.
       * @default {}
       */
      outputs?: {
        [key: string]: unknown;
      };
    };
    /**
     * StepRunResponseMetadata
     * @description Response metadata for step runs.
     */
    StepRunResponseMetadata: {
      /** The workspace of this resource. */
      workspace: components["schemas"]["WorkspaceResponse"];
      /** The configuration of the step. */
      config: components["schemas"]["StepConfiguration"];
      /** The spec of the step. */
      spec: components["schemas"]["StepSpec"];
      /** The cache key of the step run. */
      cache_key?: string;
      /** The code hash of the step run. */
      code_hash?: string;
      /** The docstring of the step function or class. */
      docstring?: string;
      /** The source code of the step function or class. */
      source_code?: string;
      /**
       * The start time of the step run.
       * Format: date-time
       */
      start_time?: string;
      /**
       * The end time of the step run.
       * Format: date-time
       */
      end_time?: string;
      /** Logs associated with this step run. */
      logs?: components["schemas"]["LogsResponse"];
      /**
       * The deployment associated with the step run.
       * Format: uuid
       */
      deployment_id: string;
      /**
       * The ID of the pipeline run that this step run belongs to.
       * Format: uuid
       */
      pipeline_run_id: string;
      /**
       * The ID of the original step run if this step was cached.
       * Format: uuid
       */
      original_step_run_id?: string;
      /** The IDs of the parent steps of this step run. */
      parent_step_ids?: string[];
      /**
       * Metadata associated with this step run.
       * @default {}
       */
      run_metadata?: {
        [key: string]: unknown;
      };
    };
    /**
     * StepRunUpdate
     * @description Update model for step runs.
     */
    StepRunUpdate: {
      /**
       * The IDs of the output artifact versions of the step run.
       * @default {}
       */
      outputs?: {
        [key: string]: unknown;
      };
      /**
       * The IDs of artifact versions that were saved by this step run.
       * @default {}
       */
      saved_artifact_versions?: {
        [key: string]: unknown;
      };
      /**
       * The IDs of artifact versions that were loaded by this step run.
       * @default {}
       */
      loaded_artifact_versions?: {
        [key: string]: unknown;
      };
      /** The status of the step. */
      status?: components["schemas"]["ExecutionStatus"];
      /**
       * The end time of the step run.
       * Format: date-time
       */
      end_time?: string;
    };
    /**
     * StepSpec
     * @description Specification of a pipeline.
     */
    StepSpec: {
      source: components["schemas"]["Source"];
      /** Upstream Steps */
      upstream_steps: string[];
      /**
       * Inputs
       * @default {}
       */
      inputs?: {
        [key: string]: unknown;
      };
      /**
       * Pipeline Parameter Name
       * @default
       */
      pipeline_parameter_name?: string;
    };
    /**
     * TagRequest
     * @description Request model for tags.
     */
    TagRequest: {
      /**
       * Name
       * @description The unique title of the tag.
       */
      name: string;
      /** @description The color variant assigned to the tag. */
      color?: components["schemas"]["ColorVariants"];
    };
    /**
     * TagResponse
     * @description Response model for tags.
     */
    TagResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["TagResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["BaseResponseMetadata"];
      /**
       * Name
       * @description The unique title of the tag.
       */
      name: string;
    };
    /**
     * TagResponseBody
     * @description Response body for tags.
     */
    TagResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /** @description The color variant assigned to the tag. */
      color?: components["schemas"]["ColorVariants"];
      /**
       * Tagged Count
       * @description The count of resources tagged with this tag.
       */
      tagged_count: number;
    };
    /**
     * TagUpdate
     * @description Update model for tags.
     */
    TagUpdate: {
      /** Name */
      name?: string;
      color?: components["schemas"]["ColorVariants"];
    };
    /**
     * UserRequest
     * @description Request model for users.
     */
    UserRequest: {
      /** The unique username for the account. */
      name: string;
      /**
       * The full name for the account owner. Only relevant for user accounts.
       * @default
       */
      full_name?: string;
      /** The email address associated with the account. */
      email?: string;
      /**
       * Whether the user agreed to share their email. Only relevant for user accounts
       * @description `null` if not answered, `true` if agreed, `false` if skipped.
       */
      email_opted_in?: boolean;
      /** JWT Token for the connected Hub account. Only relevant for user accounts. */
      hub_token?: string;
      /** A password for the user. */
      password?: string;
      /** Activation Token */
      activation_token?: string;
      /**
       * The external user ID associated with the account.
       * Format: uuid
       */
      external_user_id?: string;
      /**
       * Whether the account is active.
       * @default false
       */
      active?: boolean;
    };
    /**
     * UserResponse
     * @description Response model for user and service accounts.
     *
     * This returns the activation_token that is required for the
     * user-invitation-flow of the frontend. The email is returned optionally as
     * well for use by the analytics on the client-side.
     */
    UserResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["UserResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["UserResponseMetadata"];
      /** The unique username for the account. */
      name: string;
    };
    /**
     * UserResponseBody
     * @description Response body for users.
     */
    UserResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
      /**
       * Whether the account is active.
       * @default false
       */
      active?: boolean;
      /** The activation token for the user. Only relevant for user accounts. */
      activation_token?: string;
      /**
       * The full name for the account owner. Only relevant for user accounts.
       * @default
       */
      full_name?: string;
      /**
       * Whether the user agreed to share their email. Only relevant for user accounts
       * @description `null` if not answered, `true` if agreed, `false` if skipped.
       */
      email_opted_in?: boolean;
      /** Indicates whether this is a service account or a user account. */
      is_service_account: boolean;
    };
    /**
     * UserResponseMetadata
     * @description Response metadata for users.
     */
    UserResponseMetadata: {
      /**
       * The email address associated with the account. Only relevant for user accounts.
       * @default
       */
      email?: string;
      /** JWT Token for the connected Hub account. Only relevant for user accounts. */
      hub_token?: string;
      /**
       * The external user ID associated with the account. Only relevant for user accounts.
       * Format: uuid
       */
      external_user_id?: string;
    };
    /**
     * UserUpdate
     * @description Update model for users.
     */
    UserUpdate: {
      /** The unique username for the account. */
      name?: string;
      /**
       * The full name for the account owner. Only relevant for user accounts.
       * @default
       */
      full_name?: string;
      /** The email address associated with the account. */
      email?: string;
      /**
       * Whether the user agreed to share their email. Only relevant for user accounts
       * @description `null` if not answered, `true` if agreed, `false` if skipped.
       */
      email_opted_in?: boolean;
      /** JWT Token for the connected Hub account. Only relevant for user accounts. */
      hub_token?: string;
      /** A password for the user. */
      password?: string;
      /** Activation Token */
      activation_token?: string;
      /**
       * The external user ID associated with the account.
       * Format: uuid
       */
      external_user_id?: string;
      /**
       * Whether the account is active.
       * @default false
       */
      active?: boolean;
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
    /**
     * VisualizationType
     * @description All currently available visualization types.
     * @enum {string}
     */
    VisualizationType: "csv" | "html" | "image" | "markdown";
    /**
     * WorkspaceRequest
     * @description Request model for workspaces.
     */
    WorkspaceRequest: {
      /** The unique name of the workspace. */
      name: string;
      /**
       * The description of the workspace.
       * @default
       */
      description?: string;
    };
    /**
     * WorkspaceResponse
     * @description Response model for workspaces.
     */
    WorkspaceResponse: {
      /**
       * The unique resource id.
       * Format: uuid
       */
      id: string;
      /**
       * Permission Denied
       * @default false
       */
      permission_denied?: boolean;
      /** The body of the resource. */
      body?: components["schemas"]["WorkspaceResponseBody"];
      /** The metadata related to this resource. */
      metadata?: components["schemas"]["WorkspaceResponseMetadata"];
      /** The unique name of the workspace. */
      name: string;
    };
    /**
     * WorkspaceResponseBody
     * @description Response body for workspaces.
     */
    WorkspaceResponseBody: {
      /**
       * The timestamp when this resource was created.
       * Format: date-time
       */
      created?: string;
      /**
       * The timestamp when this resource was last updated.
       * Format: date-time
       */
      updated?: string;
    };
    /**
     * WorkspaceResponseMetadata
     * @description Response metadata for workspaces.
     */
    WorkspaceResponseMetadata: {
      /**
       * The description of the workspace.
       * @default
       */
      description?: string;
    };
    /**
     * WorkspaceUpdate
     * @description Update model for workspaces.
     */
    WorkspaceUpdate: {
      /** The unique name of the workspace. */
      name?: string;
      /**
       * The description of the workspace.
       * @default
       */
      description?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
};

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export type operations = {

  /**
   * Health
   * @description Get health status of the server.
   *
   * Returns:
   *     String representing the health status of the server.
   */
  health_health_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /**
   * Token
   * @description OAuth2 token endpoint.
   *
   * Args:
   *     request: The request object.
   *     response: The response object.
   *     auth_form_data: The OAuth 2.0 authentication form data.
   *
   * Returns:
   *     An access token or a redirect response.
   *
   * Raises:
   *     ValueError: If the grant type is invalid.
   */
  token_api_v1_login_post: {
    requestBody?: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["Body_token_api_v1_login_post"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["OAuthTokenResponse"] | components["schemas"]["OAuthRedirectResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Logout
   * @description Logs out the user.
   *
   * Args:
   *     response: The response object.
   */
  logout_api_v1_logout_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Device Authorization
   * @description OAuth2 device authorization endpoint.
   *
   * This endpoint implements the OAuth2 device authorization grant flow as
   * defined in https://tools.ietf.org/html/rfc8628. It is called to initiate
   * the device authorization flow by requesting a device and user code for a
   * given client ID.
   *
   * For a new client ID, a new OAuth device is created, stored in the DB and
   * returned to the client along with a pair of newly generated device and user
   * codes. If a device for the given client ID already exists, the existing
   * DB entry is reused and new device and user codes are generated.
   *
   * Args:
   *     request: The request object.
   *     client_id: The client ID.
   *
   * Returns:
   *     The device authorization response.
   */
  device_authorization_api_v1_device_authorization_post: {
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["Body_device_authorization_api_v1_device_authorization_post"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["OAuthDeviceAuthorizationResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Api Token
   * @description Get a workload API token for the current user.
   *
   * Args:
   *     pipeline_id: The ID of the pipeline to get the API token for.
   *     schedule_id: The ID of the schedule to get the API token for.
   *     expires_minutes: The number of minutes for which the API token should
   *         be valid. If not provided, the API token will be valid indefinitely.
   *     auth_context: The authentication context.
   *
   * Returns:
   *     The API token.
   *
   * Raises:
   *     HTTPException: If the user is not authenticated.
   */
  api_token_api_v1_api_token_get: {
    parameters: {
      query?: {
        pipeline_id?: string;
        schedule_id?: string;
        expires_minutes?: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Authorized Devices
   * @description Gets a page of OAuth2 authorized devices belonging to the current user.
   *
   * Args:
   *     filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *     auth_context: The current auth context.
   *
   * Returns:
   *     Page of OAuth2 authorized device objects.
   */
  list_authorized_devices_api_v1_devices_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_user?: string;
        expires?: string;
        client_id?: string;
        status?: components["schemas"]["OAuthDeviceStatus"] | string;
        trusted_device?: boolean | string;
        failed_auth_attempts?: number | string;
        last_login?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_OAuthDeviceResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Authorization Device
   * @description Gets a specific OAuth2 authorized device using its unique ID.
   *
   * Args:
   *     device_id: The ID of the OAuth2 authorized device to get.
   *     user_code: The user code of the OAuth2 authorized device to get. Needs
   *         to be specified with devices that have not been verified yet.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *     auth_context: The current auth context.
   *
   * Returns:
   *     A specific OAuth2 authorized device object.
   *
   * Raises:
   *     KeyError: If the device with the given ID does not exist, does not
   *         belong to the current user or could not be verified using the
   *         given user code.
   */
  get_authorization_device_api_v1_devices__device_id__get: {
    parameters: {
      query?: {
        user_code?: string;
        hydrate?: boolean;
      };
      path: {
        device_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["OAuthDeviceResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Authorized Device
   * @description Updates a specific OAuth2 authorized device using its unique ID.
   *
   * Args:
   *     device_id: The ID of the OAuth2 authorized device to update.
   *     update: The model containing the attributes to update.
   *     auth_context: The current auth context.
   *
   * Returns:
   *     The updated OAuth2 authorized device object.
   *
   * Raises:
   *     KeyError: If the device with the given ID does not exist or does not
   *         belong to the current user.
   */
  update_authorized_device_api_v1_devices__device_id__put: {
    parameters: {
      path: {
        device_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["OAuthDeviceUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["OAuthDeviceResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Authorized Device
   * @description Deletes a specific OAuth2 authorized device using its unique ID.
   *
   * Args:
   *     device_id: The ID of the OAuth2 authorized device to delete.
   *     auth_context: The current auth context.
   *
   * Raises:
   *     KeyError: If the device with the given ID does not exist or does not
   *         belong to the current user.
   */
  delete_authorized_device_api_v1_devices__device_id__delete: {
    parameters: {
      path: {
        device_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Verify Authorized Device
   * @description Verifies a specific OAuth2 authorized device using its unique ID.
   *
   * This endpoint implements the OAuth2 device authorization grant flow as
   * defined in https://tools.ietf.org/html/rfc8628. It is called to verify
   * the user code for a given device ID.
   *
   * If the user code is valid, the device is marked as verified and associated
   * with the user that authorized the device. This association is required to
   * be able to issue access tokens or revoke the device later on.
   *
   * Args:
   *     device_id: The ID of the OAuth2 authorized device to update.
   *     request: The model containing the verification request.
   *     auth_context: The current auth context.
   *
   * Returns:
   *     The updated OAuth2 authorized device object.
   *
   * Raises:
   *     ValueError: If the device verification request fails.
   */
  verify_authorized_device_api_v1_devices__device_id__verify_put: {
    parameters: {
      path: {
        device_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["OAuthDeviceVerificationRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["OAuthDeviceResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Pipelines
   * @description Gets a list of pipelines.
   *
   * Args:
   *     pipeline_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     List of pipeline objects.
   */
  list_pipelines_api_v1_pipelines_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        version?: string;
        version_hash?: string;
        docstring?: string;
        workspace_id?: string;
        user_id?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_PipelineResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Pipeline
   * @description Gets a specific pipeline using its unique id.
   *
   * Args:
   *     pipeline_id: ID of the pipeline to get.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     A specific pipeline object.
   */
  get_pipeline_api_v1_pipelines__pipeline_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        pipeline_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PipelineResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Pipeline
   * @description Updates the attribute on a specific pipeline using its unique id.
   *
   * Args:
   *     pipeline_id: ID of the pipeline to get.
   *     pipeline_update: the model containing the attributes to update.
   *
   * Returns:
   *     The updated pipeline object.
   */
  update_pipeline_api_v1_pipelines__pipeline_id__put: {
    parameters: {
      path: {
        pipeline_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PipelineUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PipelineResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Pipeline
   * @description Deletes a specific pipeline.
   *
   * Args:
   *     pipeline_id: ID of the pipeline to delete.
   */
  delete_pipeline_api_v1_pipelines__pipeline_id__delete: {
    parameters: {
      path: {
        pipeline_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Pipeline Runs
   * @description Get pipeline runs according to query filters.
   *
   * Args:
   *     pipeline_run_filter_model: Filter model used for pagination, sorting,
   *         filtering
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The pipeline runs according to query filters.
   */
  list_pipeline_runs_api_v1_pipelines__pipeline_id__runs_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        orchestrator_run_id?: string;
        workspace_id?: string;
        user_id?: string;
        stack_id?: string;
        schedule_id?: string;
        build_id?: string;
        deployment_id?: string;
        code_repository_id?: string;
        status?: string;
        start_time?: string;
        end_time?: string;
        unlisted?: boolean;
      };
      path: {
        pipeline_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_PipelineRunResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Pipeline Spec
   * @description Gets the spec of a specific pipeline using its unique id.
   *
   * Args:
   *     pipeline_id: ID of the pipeline to get.
   *
   * Returns:
   *     The spec of the pipeline.
   */
  get_pipeline_spec_api_v1_pipelines__pipeline_id__pipeline_spec_get: {
    parameters: {
      path: {
        pipeline_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PipelineSpec"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Workspaces
   * @description Lists all workspaces in the organization.
   *
   * Args:
   *     workspace_filter_model: Filter model used for pagination, sorting,
   *         filtering,
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     A list of workspaces.
   */
  list_workspaces_api_v1_workspaces_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        name?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_WorkspaceResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Workspace
   * @description Creates a workspace based on the requestBody.
   *
   * # noqa: DAR401
   *
   * Args:
   *     workspace: Workspace to create.
   *
   * Returns:
   *     The created workspace.
   */
  create_workspace_api_v1_workspaces_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["WorkspaceResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Workspace
   * @description Get a workspace for given name.
   *
   * # noqa: DAR401
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The requested workspace.
   */
  get_workspace_api_v1_workspaces__workspace_name_or_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        workspace_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["WorkspaceResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Workspace
   * @description Get a workspace for given name.
   *
   * # noqa: DAR401
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace to update.
   *     workspace_update: the workspace to use to update
   *
   * Returns:
   *     The updated workspace.
   */
  update_workspace_api_v1_workspaces__workspace_name_or_id__put: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["WorkspaceUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["WorkspaceResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Workspace
   * @description Deletes a workspace.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   */
  delete_workspace_api_v1_workspaces__workspace_name_or_id__delete: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Workspace Stacks
   * @description Get stacks that are part of a specific workspace for the user.
   *
   * # noqa: DAR401
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     stack_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     All stacks part of the specified workspace.
   */
  list_workspace_stacks_api_v1_workspaces__workspace_name_or_id__stacks_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        description?: string;
        workspace_id?: string;
        user_id?: string;
        component_id?: string;
      };
      path: {
        workspace_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_StackResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Stack
   * @description Creates a stack for a particular workspace.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     stack: Stack to register.
   *
   * Returns:
   *     The created stack.
   *
   * Raises:
   *     IllegalOperationError: If the workspace specified in the stack
   *         does not match the current workspace.
   */
  create_stack_api_v1_workspaces__workspace_name_or_id__stacks_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["StackRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["StackResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Workspace Stack Components
   * @description List stack components that are part of a specific workspace.
   *
   * # noqa: DAR401
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     component_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     All stack components part of the specified workspace.
   */
  list_workspace_stack_components_api_v1_workspaces__workspace_name_or_id__components_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        scope_type?: string;
        name?: string;
        flavor?: string;
        type?: string;
        workspace_id?: string;
        user_id?: string;
        connector_id?: string;
        stack_id?: string;
      };
      path: {
        workspace_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_ComponentResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Stack Component
   * @description Creates a stack component.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     component: Stack component to register.
   *
   * Returns:
   *     The created stack component.
   *
   * Raises:
   *     IllegalOperationError: If the workspace specified in the stack
   *         component does not match the current workspace.
   */
  create_stack_component_api_v1_workspaces__workspace_name_or_id__components_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ComponentRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ComponentResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Workspace Pipelines
   * @description Gets pipelines defined for a specific workspace.
   *
   * # noqa: DAR401
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     pipeline_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     All pipelines within the workspace.
   */
  list_workspace_pipelines_api_v1_workspaces__workspace_name_or_id__pipelines_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        version?: string;
        version_hash?: string;
        docstring?: string;
        workspace_id?: string;
        user_id?: string;
      };
      path: {
        workspace_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_PipelineResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Pipeline
   * @description Creates a pipeline.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     pipeline: Pipeline to create.
   *
   * Returns:
   *     The created pipeline.
   *
   * Raises:
   *     IllegalOperationError: If the workspace or user specified in the pipeline
   *         does not match the current workspace or authenticated user.
   */
  create_pipeline_api_v1_workspaces__workspace_name_or_id__pipelines_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PipelineRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PipelineResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Workspace Builds
   * @description Gets builds defined for a specific workspace.
   *
   * # noqa: DAR401
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     build_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     All builds within the workspace.
   */
  list_workspace_builds_api_v1_workspaces__workspace_name_or_id__pipeline_builds_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        workspace_id?: string;
        user_id?: string;
        pipeline_id?: string;
        stack_id?: string;
        is_local?: boolean;
        contains_code?: boolean;
        zenml_version?: string;
        python_version?: string;
        checksum?: string;
      };
      path: {
        workspace_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_PipelineBuildResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Build
   * @description Creates a build.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     build: Build to create.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     The created build.
   *
   * Raises:
   *     IllegalOperationError: If the workspace specified in the build
   *         does not match the current workspace.
   */
  create_build_api_v1_workspaces__workspace_name_or_id__pipeline_builds_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PipelineBuildRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PipelineBuildResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Workspace Deployments
   * @description Gets deployments defined for a specific workspace.
   *
   * # noqa: DAR401
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     deployment_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     All deployments within the workspace.
   */
  list_workspace_deployments_api_v1_workspaces__workspace_name_or_id__pipeline_deployments_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        workspace_id?: string;
        user_id?: string;
        pipeline_id?: string;
        stack_id?: string;
        build_id?: string;
        schedule_id?: string;
      };
      path: {
        workspace_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_PipelineDeploymentResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Deployment
   * @description Creates a deployment.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     deployment: Deployment to create.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     The created deployment.
   *
   * Raises:
   *     IllegalOperationError: If the workspace specified in the
   *         deployment does not match the current workspace.
   */
  create_deployment_api_v1_workspaces__workspace_name_or_id__pipeline_deployments_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PipelineDeploymentRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PipelineDeploymentResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Runs
   * @description Get pipeline runs according to query filters.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     runs_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The pipeline runs according to query filters.
   */
  list_runs_api_v1_workspaces__workspace_name_or_id__runs_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        orchestrator_run_id?: string;
        pipeline_id?: string;
        workspace_id?: string;
        user_id?: string;
        stack_id?: string;
        schedule_id?: string;
        build_id?: string;
        deployment_id?: string;
        code_repository_id?: string;
        status?: string;
        start_time?: string;
        end_time?: string;
        unlisted?: boolean;
      };
      path: {
        workspace_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_PipelineRunResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Pipeline Run
   * @description Creates a pipeline run.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     pipeline_run: Pipeline run to create.
   *
   * Returns:
   *     The created pipeline run.
   *
   * Raises:
   *     IllegalOperationError: If the workspace specified in the
   *         pipeline run does not match the current workspace.
   */
  create_pipeline_run_api_v1_workspaces__workspace_name_or_id__runs_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PipelineRunRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PipelineRunResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Schedule
   * @description Creates a schedule.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     schedule: Schedule to create.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     The created schedule.
   *
   * Raises:
   *     IllegalOperationError: If the workspace or user specified in the
   *         schedule does not match the current workspace or authenticated user.
   */
  create_schedule_api_v1_workspaces__workspace_name_or_id__schedules_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ScheduleRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ScheduleResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Or Create Pipeline Run
   * @description Get or create a pipeline run.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     pipeline_run: Pipeline run to create.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     The pipeline run and a boolean indicating whether the run was created
   *     or not.
   *
   * Raises:
   *     IllegalOperationError: If the workspace or user specified in the
   *         pipeline run does not match the current workspace or authenticated
   *         user.
   */
  get_or_create_pipeline_run_api_v1_workspaces__workspace_name_or_id__runs_get_or_create_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PipelineRunRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": [components["schemas"]["PipelineRunResponse"], boolean];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Run Metadata
   * @description Creates run metadata.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     run_metadata: The run metadata to create.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     The created run metadata.
   *
   * Raises:
   *     IllegalOperationError: If the workspace or user specified in the run
   *         metadata does not match the current workspace or authenticated user.
   *     RuntimeError: If the resource type is not supported.
   */
  create_run_metadata_api_v1_workspaces__workspace_name_or_id__run_metadata_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RunMetadataRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["RunMetadataResponse"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Secret
   * @description Creates a secret.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     secret: Secret to create.
   *
   * Returns:
   *     The created secret.
   *
   * Raises:
   *     IllegalOperationError: If the workspace specified in the
   *         secret does not match the current workspace.
   */
  create_secret_api_v1_workspaces__workspace_name_or_id__secrets_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SecretRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SecretResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Workspace Code Repositories
   * @description Gets code repositories defined for a specific workspace.
   *
   * # noqa: DAR401
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     All code repositories within the workspace.
   */
  list_workspace_code_repositories_api_v1_workspaces__workspace_name_or_id__code_repositories_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        workspace_id?: string;
        user_id?: string;
      };
      path: {
        workspace_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_CodeRepositoryResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Code Repository
   * @description Creates a code repository.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     code_repository: Code repository to create.
   *
   * Returns:
   *     The created code repository.
   *
   * Raises:
   *     IllegalOperationError: If the workspace or user specified in the
   *         code repository does not match the current workspace or
   *         authenticated user.
   */
  create_code_repository_api_v1_workspaces__workspace_name_or_id__code_repositories_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CodeRepositoryRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["CodeRepositoryResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Workspace Statistics
   * @description Gets statistics of a workspace.
   *
   * # noqa: DAR401
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace to get statistics for.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     All pipelines within the workspace.
   */
  get_workspace_statistics_api_v1_workspaces__workspace_name_or_id__statistics_get: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Workspace Service Connectors
   * @description List service connectors that are part of a specific workspace.
   *
   * # noqa: DAR401
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     connector_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     All service connectors part of the specified workspace.
   */
  list_workspace_service_connectors_api_v1_workspaces__workspace_name_or_id__service_connectors_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        scope_type?: string;
        name?: string;
        connector_type?: string;
        workspace_id?: string;
        user_id?: string;
        auth_method?: string;
        resource_type?: string;
        resource_id?: string;
        labels_str?: string;
        secret_id?: string;
      };
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_ServiceConnectorResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Service Connector
   * @description Creates a service connector.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     connector: Service connector to register.
   *
   * Returns:
   *     The created service connector.
   *
   * Raises:
   *     IllegalOperationError: If the workspace or user specified in the service
   *         connector does not match the current workspace or authenticated
   *         user.
   */
  create_service_connector_api_v1_workspaces__workspace_name_or_id__service_connectors_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ServiceConnectorRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceConnectorResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Service Connector Resources
   * @description List resources that can be accessed by service connectors.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     connector_type: the service connector type identifier to filter by.
   *     resource_type: the resource type identifier to filter by.
   *     resource_id: the resource identifier to filter by.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     The matching list of resources that available service
   *     connectors have access to.
   */
  list_service_connector_resources_api_v1_workspaces__workspace_name_or_id__service_connectors_resources_get: {
    parameters: {
      query?: {
        connector_type?: string;
        resource_type?: string;
        resource_id?: string;
      };
      path: {
        workspace_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceConnectorResourcesModel"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Model
   * @description Create a new model.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     model: The model to create.
   *
   * Returns:
   *     The created model.
   *
   * Raises:
   *     IllegalOperationError: If the workspace or user specified in the
   *         model does not match the current workspace or authenticated
   *         user.
   */
  create_model_api_v1_workspaces__workspace_name_or_id__models_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModelRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ModelResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Model Version
   * @description Create a new model version.
   *
   * Args:
   *     model_name_or_id: Name or ID of the model.
   *     workspace_name_or_id: Name or ID of the workspace.
   *     model_version: The model version to create.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     The created model version.
   *
   * Raises:
   *     IllegalOperationError: If the workspace specified in the
   *         model version does not match the current workspace.
   */
  create_model_version_api_v1_workspaces__workspace_name_or_id__models__model_name_or_id__model_versions_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
        model_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModelVersionRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ModelVersionResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Model Version Artifact Link
   * @description Create a new model version to artifact link.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     model_version_id: ID of the model version.
   *     model_version_artifact_link: The model version to artifact link to create.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     The created model version to artifact link.
   *
   * Raises:
   *     IllegalOperationError: If the workspace or user specified in the
   *         model version does not match the current workspace or authenticated
   *         user.
   */
  create_model_version_artifact_link_api_v1_workspaces__workspace_name_or_id__model_versions__model_version_id__artifacts_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
        model_version_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModelVersionArtifactRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ModelVersionArtifactResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Model Version Pipeline Run Link
   * @description Create a new model version to pipeline run link.
   *
   * Args:
   *     workspace_name_or_id: Name or ID of the workspace.
   *     model_version_id: ID of the model version.
   *     model_version_pipeline_run_link: The model version to pipeline run link to create.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     - If Model Version to Pipeline Run Link already exists - returns the existing link.
   *     - Otherwise, returns the newly created model version to pipeline run link.
   *
   * Raises:
   *     IllegalOperationError: If the workspace or user specified in the
   *         model version does not match the current workspace or authenticated
   *         user.
   */
  create_model_version_pipeline_run_link_api_v1_workspaces__workspace_name_or_id__model_versions__model_version_id__runs_post: {
    parameters: {
      path: {
        workspace_name_or_id: string;
        model_version_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModelVersionPipelineRunRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ModelVersionPipelineRunResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Flavors
   * @description Returns all flavors.
   *
   * Args:
   *     flavor_filter_model: Filter model used for pagination, sorting,
   *                          filtering
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     All flavors.
   */
  list_flavors_api_v1_flavors_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        type?: string;
        integration?: string;
        workspace_id?: string;
        user_id?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_FlavorResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Flavor
   * @description Creates a stack component flavor.
   *
   * Args:
   *     flavor: Stack component flavor to register.
   *
   * Returns:
   *     The created stack component flavor.
   */
  create_flavor_api_v1_flavors_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["FlavorRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FlavorResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Flavor
   * @description Returns the requested flavor.
   *
   * Args:
   *     flavor_id: ID of the flavor.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The requested stack.
   */
  get_flavor_api_v1_flavors__flavor_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        flavor_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FlavorResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Flavor
   * @description Updates a flavor.
   *
   * # noqa: DAR401
   *
   * Args:
   *     flavor_id: ID of the flavor to update.
   *     flavor_update: Flavor update.
   *
   * Returns:
   *     The updated flavor.
   */
  update_flavor_api_v1_flavors__flavor_id__put: {
    parameters: {
      path: {
        flavor_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["FlavorUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FlavorResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Flavor
   * @description Deletes a flavor.
   *
   * Args:
   *     flavor_id: ID of the flavor.
   */
  delete_flavor_api_v1_flavors__flavor_id__delete: {
    parameters: {
      path: {
        flavor_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Sync Flavors
   * @description Purge all in-built and integration flavors from the DB and sync.
   *
   * Returns:
   *     None if successful. Raises an exception otherwise.
   */
  sync_flavors_api_v1_flavors_sync_patch: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Runs
   * @description Get pipeline runs according to query filters.
   *
   * Args:
   *     runs_filter_model: Filter model used for pagination, sorting, filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The pipeline runs according to query filters.
   */
  list_runs_api_v1_runs_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        orchestrator_run_id?: string;
        pipeline_id?: string;
        workspace_id?: string;
        user_id?: string;
        stack_id?: string;
        schedule_id?: string;
        build_id?: string;
        deployment_id?: string;
        code_repository_id?: string;
        status?: string;
        start_time?: string;
        end_time?: string;
        unlisted?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_PipelineRunResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Run
   * @description Get a specific pipeline run using its ID.
   *
   * Args:
   *     run_id: ID of the pipeline run to get.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The pipeline run.
   */
  get_run_api_v1_runs__run_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        run_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PipelineRunResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Run
   * @description Updates a run.
   *
   * Args:
   *     run_id: ID of the run.
   *     run_model: Run model to use for the update.
   *
   * Returns:
   *     The updated run model.
   */
  update_run_api_v1_runs__run_id__put: {
    parameters: {
      path: {
        run_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PipelineRunUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PipelineRunResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Run
   * @description Deletes a run.
   *
   * Args:
   *     run_id: ID of the run.
   */
  delete_run_api_v1_runs__run_id__delete: {
    parameters: {
      path: {
        run_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Run Dag
   * @description Get the DAG for a given pipeline run.
   *
   * Args:
   *     run_id: ID of the pipeline run to use to get the DAG.
   *
   * Returns:
   *     The DAG for a given pipeline run.
   */
  get_run_dag_api_v1_runs__run_id__graph_get: {
    parameters: {
      path: {
        run_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["LineageGraph"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Run Steps
   * @description Get all steps for a given pipeline run.
   *
   * Args:
   *     run_id: ID of the pipeline run.
   *     step_run_filter_model: Filter model used for pagination, sorting,
   *         filtering
   *
   * Returns:
   *     The steps for a given pipeline run.
   */
  get_run_steps_api_v1_runs__run_id__steps_get: {
    parameters: {
      query?: {
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        code_hash?: string;
        cache_key?: string;
        status?: string;
        start_time?: string;
        end_time?: string;
        pipeline_run_id?: string;
        original_step_run_id?: string;
        user_id?: string;
        workspace_id?: string;
      };
      path: {
        run_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_StepRunResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Pipeline Configuration
   * @description Get the pipeline configuration of a specific pipeline run using its ID.
   *
   * Args:
   *     run_id: ID of the pipeline run to get.
   *
   * Returns:
   *     The pipeline configuration of the pipeline run.
   */
  get_pipeline_configuration_api_v1_runs__run_id__pipeline_configuration_get: {
    parameters: {
      path: {
        run_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Run Status
   * @description Get the status of a specific pipeline run.
   *
   * Args:
   *     run_id: ID of the pipeline run for which to get the status.
   *
   * Returns:
   *     The status of the pipeline run.
   */
  get_run_status_api_v1_runs__run_id__status_get: {
    parameters: {
      path: {
        run_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ExecutionStatus"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Run Metadata
   * @description Get run metadata according to query filters.
   *
   * Args:
   *     run_metadata_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The pipeline runs according to query filters.
   */
  list_run_metadata_api_v1_run_metadata_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        resource_id?: string;
        resource_type?: components["schemas"]["MetadataResourceTypes"];
        stack_component_id?: string;
        key?: string;
        type?: string | components["schemas"]["MetadataTypeEnum"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_RunMetadataResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Run Metadata
   * @description Get run metadata by ID.
   *
   * Args:
   *     run_metadata_id: The ID of run metadata.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The run metadata response.
   */
  get_run_metadata_api_v1_run_metadata__run_metadata_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        run_metadata_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["RunMetadataResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Schedules
   * @description Gets a list of schedules.
   *
   * Args:
   *     schedule_filter_model: Filter model used for pagination, sorting,
   *         filtering
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     List of schedule objects.
   */
  list_schedules_api_v1_schedules_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        workspace_id?: string;
        user_id?: string;
        pipeline_id?: string;
        orchestrator_id?: string;
        active?: boolean;
        cron_expression?: string;
        start_time?: string;
        end_time?: string;
        interval_second?: number;
        catchup?: boolean;
        name?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_ScheduleResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Schedule
   * @description Gets a specific schedule using its unique id.
   *
   * Args:
   *     schedule_id: ID of the schedule to get.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     A specific schedule object.
   */
  get_schedule_api_v1_schedules__schedule_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        schedule_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ScheduleResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Schedule
   * @description Updates the attribute on a specific schedule using its unique id.
   *
   * Args:
   *     schedule_id: ID of the schedule to get.
   *     schedule_update: the model containing the attributes to update.
   *
   * Returns:
   *     The updated schedule object.
   */
  update_schedule_api_v1_schedules__schedule_id__put: {
    parameters: {
      path: {
        schedule_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ScheduleUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ScheduleResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Schedule
   * @description Deletes a specific schedule using its unique id.
   *
   * Args:
   *     schedule_id: ID of the schedule to delete.
   */
  delete_schedule_api_v1_schedules__schedule_id__delete: {
    parameters: {
      path: {
        schedule_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Secrets
   * @description Gets a list of secrets.
   *
   * Args:
   *     secret_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     List of secret objects.
   */
  list_secrets_api_v1_secrets_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        scope?: components["schemas"]["SecretScope"] | string;
        workspace_id?: string;
        user_id?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_SecretResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Secret
   * @description Gets a specific secret using its unique id.
   *
   * Args:
   *     secret_id: ID of the secret to get.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     A specific secret object.
   */
  get_secret_api_v1_secrets__secret_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        secret_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SecretResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Secret
   * @description Updates the attribute on a specific secret using its unique id.
   *
   * Args:
   *     secret_id: ID of the secret to get.
   *     secret_update: the model containing the attributes to update.
   *     patch_values: Whether to patch the secret values or replace them.
   *
   * Returns:
   *     The updated secret object.
   */
  update_secret_api_v1_secrets__secret_id__put: {
    parameters: {
      query?: {
        patch_values?: boolean;
      };
      path: {
        secret_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SecretUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["SecretResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Secret
   * @description Deletes a specific secret using its unique id.
   *
   * Args:
   *     secret_id: ID of the secret to delete.
   */
  delete_secret_api_v1_secrets__secret_id__delete: {
    parameters: {
      path: {
        secret_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Version
   * @description Get version of the server.
   *
   * Returns:
   *     String representing the version of the server.
   */
  version_api_v1_version_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Server Info
   * @description Get information about the server.
   *
   * Returns:
   *     Information about the server.
   */
  server_info_api_v1_info_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ServerModel"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Service Accounts
   * @description Returns a list of service accounts.
   *
   * Args:
   *     filter_model: Model that takes care of filtering, sorting and
   *         pagination.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     A list of service accounts matching the filter.
   */
  list_service_accounts_api_v1_service_accounts_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        name?: string;
        description?: string;
        active?: boolean | string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_ServiceAccountResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Service Account
   * @description Creates a service account.
   *
   * Args:
   *     service_account: Service account to create.
   *
   * Returns:
   *     The created service account.
   */
  create_service_account_api_v1_service_accounts_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ServiceAccountRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceAccountResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Service Account
   * @description Returns a specific service account.
   *
   * Args:
   *     service_account_name_or_id: Name or ID of the service account.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The service account matching the given name or ID.
   */
  get_service_account_api_v1_service_accounts__service_account_name_or_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        service_account_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceAccountResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Service Account
   * @description Updates a specific service account.
   *
   * Args:
   *     service_account_name_or_id: Name or ID of the service account.
   *     service_account_update: the service account to use for the update.
   *
   * Returns:
   *     The updated service account.
   */
  update_service_account_api_v1_service_accounts__service_account_name_or_id__put: {
    parameters: {
      path: {
        service_account_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ServiceAccountUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceAccountResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Service Account
   * @description Delete a specific service account.
   *
   * Args:
   *     service_account_name_or_id: Name or ID of the service account.
   */
  delete_service_account_api_v1_service_accounts__service_account_name_or_id__delete: {
    parameters: {
      path: {
        service_account_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Api Keys
   * @description List API keys associated with a service account.
   *
   * Args:
   *     service_account_id: ID of the service account to which the API keys
   *         belong.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *     filter_model: Filter model used for pagination, sorting,
   *         filtering
   *
   * Returns:
   *     All API keys matching the filter and associated with the supplied
   *     service account.
   */
  list_api_keys_api_v1_service_accounts__service_account_id__api_keys_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        service_account?: string;
        name?: string;
        description?: string;
        active?: boolean | string;
        last_login?: string;
        last_rotated?: string;
      };
      path: {
        service_account_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_APIKeyResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Api Key
   * @description Creates an API key for a service account.
   *
   * Args:
   *     service_account_id: ID of the service account for which to create the
   *         API key.
   *     api_key: API key to create.
   *
   * Returns:
   *     The created API key.
   */
  create_api_key_api_v1_service_accounts__service_account_id__api_keys_post: {
    parameters: {
      path: {
        service_account_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["APIKeyRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["APIKeyResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Api Key
   * @description Returns the requested API key.
   *
   * Args:
   *     service_account_id: ID of the service account to which the API key
   *         belongs.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *     api_key_name_or_id: Name or ID of the API key to return.
   *
   * Returns:
   *     The requested API key.
   */
  get_api_key_api_v1_service_accounts__service_account_id__api_keys__api_key_name_or_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        service_account_id: string;
        api_key_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["APIKeyResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Api Key
   * @description Updates an API key for a service account.
   *
   * Args:
   *     service_account_id: ID of the service account to which the API key
   *         belongs.
   *     api_key_name_or_id: Name or ID of the API key to update.
   *     api_key_update: API key update.
   *
   * Returns:
   *     The updated API key.
   */
  update_api_key_api_v1_service_accounts__service_account_id__api_keys__api_key_name_or_id__put: {
    parameters: {
      path: {
        service_account_id: string;
        api_key_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["APIKeyUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["APIKeyResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Api Key
   * @description Deletes an API key.
   *
   * Args:
   *     service_account_id: ID of the service account to which the API key
   *         belongs.
   *     api_key_name_or_id: Name or ID of the API key to delete.
   */
  delete_api_key_api_v1_service_accounts__service_account_id__api_keys__api_key_name_or_id__delete: {
    parameters: {
      path: {
        service_account_id: string;
        api_key_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Rotate Api Key
   * @description Rotate an API key.
   *
   * Args:
   *     service_account_id: ID of the service account to which the API key
   *         belongs.
   *     api_key_name_or_id: Name or ID of the API key to rotate.
   *     rotate_request: API key rotation request.
   *
   * Returns:
   *     The updated API key.
   */
  rotate_api_key_api_v1_service_accounts__service_account_id__api_keys__api_key_name_or_id__rotate_put: {
    parameters: {
      path: {
        service_account_id: string;
        api_key_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["APIKeyRotateRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["APIKeyResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Service Connectors
   * @description Get a list of all service connectors for a specific type.
   *
   * Args:
   *     connector_filter_model: Filter model used for pagination, sorting,
   *         filtering
   *     expand_secrets: Whether to expand secrets or not.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     Page with list of service connectors for a specific type.
   */
  list_service_connectors_api_v1_service_connectors_get: {
    parameters: {
      query?: {
        expand_secrets?: boolean;
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        scope_type?: string;
        name?: string;
        connector_type?: string;
        workspace_id?: string;
        user_id?: string;
        auth_method?: string;
        resource_type?: string;
        resource_id?: string;
        labels_str?: string;
        secret_id?: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_ServiceConnectorResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Service Connector
   * @description Returns the requested service connector.
   *
   * Args:
   *     connector_id: ID of the service connector.
   *     expand_secrets: Whether to expand secrets or not.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The requested service connector.
   */
  get_service_connector_api_v1_service_connectors__connector_id__get: {
    parameters: {
      query?: {
        expand_secrets?: boolean;
        hydrate?: boolean;
      };
      path: {
        connector_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceConnectorResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Service Connector
   * @description Updates a service connector.
   *
   * Args:
   *     connector_id: ID of the service connector.
   *     connector_update: Service connector to use to update.
   *
   * Returns:
   *     Updated service connector.
   */
  update_service_connector_api_v1_service_connectors__connector_id__put: {
    parameters: {
      path: {
        connector_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ServiceConnectorUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceConnectorResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Service Connector
   * @description Deletes a service connector.
   *
   * Args:
   *     connector_id: ID of the service connector.
   */
  delete_service_connector_api_v1_service_connectors__connector_id__delete: {
    parameters: {
      path: {
        connector_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Validate And Verify Service Connector Config
   * @description Verifies if a service connector configuration has access to resources.
   *
   * This requires the service connector implementation to be installed
   * on the ZenML server, otherwise a 501 Not Implemented error will be
   * returned.
   *
   * Args:
   *     connector: The service connector configuration to verify.
   *     list_resources: If True, the list of all resources accessible
   *         through the service connector is returned.
   *
   * Returns:
   *     The list of resources that the service connector configuration has
   *     access to.
   */
  validate_and_verify_service_connector_config_api_v1_service_connectors_verify_post: {
    parameters: {
      query?: {
        list_resources?: boolean;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ServiceConnectorRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceConnectorResourcesModel"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Validate And Verify Service Connector
   * @description Verifies if a service connector instance has access to one or more resources.
   *
   * This requires the service connector implementation to be installed
   * on the ZenML server, otherwise a 501 Not Implemented error will be
   * returned.
   *
   * Args:
   *     connector_id: The ID of the service connector to verify.
   *     resource_type: The type of resource to verify access to.
   *     resource_id: The ID of the resource to verify access to.
   *     list_resources: If True, the list of all resources accessible
   *         through the service connector and matching the supplied resource
   *         type and ID are returned.
   *
   * Returns:
   *     The list of resources that the service connector has access to, scoped
   *     to the supplied resource type and ID, if provided.
   */
  validate_and_verify_service_connector_api_v1_service_connectors__connector_id__verify_put: {
    parameters: {
      query?: {
        resource_type?: string;
        resource_id?: string;
        list_resources?: boolean;
      };
      path: {
        connector_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceConnectorResourcesModel"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Service Connector Client
   * @description Get a service connector client for a service connector and given resource.
   *
   * This requires the service connector implementation to be installed
   * on the ZenML server, otherwise a 501 Not Implemented error will be
   * returned.
   *
   * Args:
   *     connector_id: ID of the service connector.
   *     resource_type: Type of the resource to list.
   *     resource_id: ID of the resource to list.
   *
   * Returns:
   *     A service connector client that can be used to access the given
   *     resource.
   */
  get_service_connector_client_api_v1_service_connectors__connector_id__client_get: {
    parameters: {
      query?: {
        resource_type?: string;
        resource_id?: string;
      };
      path: {
        connector_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceConnectorResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Service Connector Types
   * @description Get a list of service connector types.
   *
   * Args:
   *     connector_type: Filter by connector type.
   *     resource_type: Filter by resource type.
   *     auth_method: Filter by auth method.
   *
   * Returns:
   *     List of service connector types.
   */
  list_service_connector_types_api_v1_service_connector_types_get: {
    parameters: {
      query?: {
        connector_type?: string;
        resource_type?: string;
        auth_method?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceConnectorTypeModel"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Service Connector Type
   * @description Returns the requested service connector type.
   *
   * Args:
   *     connector_type: the service connector type identifier.
   *
   * Returns:
   *     The requested service connector type.
   */
  get_service_connector_type_api_v1_service_connector_types__connector_type__get: {
    parameters: {
      path: {
        connector_type: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ServiceConnectorTypeModel"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Stacks
   * @description Returns all stacks.
   *
   * Args:
   *     stack_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     All stacks.
   */
  list_stacks_api_v1_stacks_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        description?: string;
        workspace_id?: string;
        user_id?: string;
        component_id?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_StackResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Stack
   * @description Returns the requested stack.
   *
   * Args:
   *     stack_id: ID of the stack.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The requested stack.
   */
  get_stack_api_v1_stacks__stack_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        stack_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["StackResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Stack
   * @description Updates a stack.
   *
   * Args:
   *     stack_id: Name of the stack.
   *     stack_update: Stack to use for the update.
   *
   * Returns:
   *     The updated stack.
   */
  update_stack_api_v1_stacks__stack_id__put: {
    parameters: {
      path: {
        stack_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["StackUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["StackResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Stack
   * @description Deletes a stack.
   *
   * Args:
   *     stack_id: Name of the stack.
   */
  delete_stack_api_v1_stacks__stack_id__delete: {
    parameters: {
      path: {
        stack_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Stack Components
   * @description Get a list of all stack components for a specific type.
   *
   * Args:
   *     component_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     List of stack components for a specific type.
   */
  list_stack_components_api_v1_components_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        scope_type?: string;
        name?: string;
        flavor?: string;
        type?: string;
        workspace_id?: string;
        user_id?: string;
        connector_id?: string;
        stack_id?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_ComponentResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Stack Component
   * @description Returns the requested stack component.
   *
   * Args:
   *     component_id: ID of the stack component.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The requested stack component.
   */
  get_stack_component_api_v1_components__component_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        component_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ComponentResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Stack Component
   * @description Updates a stack component.
   *
   * Args:
   *     component_id: ID of the stack component.
   *     component_update: Stack component to use to update.
   *
   * Returns:
   *     Updated stack component.
   */
  update_stack_component_api_v1_components__component_id__put: {
    parameters: {
      path: {
        component_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ComponentUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ComponentResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Deregister Stack Component
   * @description Deletes a stack component.
   *
   * Args:
   *     component_id: ID of the stack component.
   */
  deregister_stack_component_api_v1_components__component_id__delete: {
    parameters: {
      path: {
        component_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Stack Component Types
   * @description Get a list of all stack component types.
   *
   * Returns:
   *     List of stack components.
   */
  get_stack_component_types_api_v1_component_types_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": string[];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Run Steps
   * @description Get run steps according to query filters.
   *
   * Args:
   *     step_run_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     The run steps according to query filters.
   */
  list_run_steps_api_v1_steps_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        code_hash?: string;
        cache_key?: string;
        status?: string;
        start_time?: string;
        end_time?: string;
        pipeline_run_id?: string;
        original_step_run_id?: string;
        user_id?: string;
        workspace_id?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_StepRunResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Run Step
   * @description Create a run step.
   *
   * Args:
   *     step: The run step to create.
   *
   * Returns:
   *     The created run step.
   */
  create_run_step_api_v1_steps_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["StepRunRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["StepRunResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Step
   * @description Get one specific step.
   *
   * Args:
   *     step_id: ID of the step to get.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The step.
   */
  get_step_api_v1_steps__step_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        step_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["StepRunResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Step
   * @description Updates a step.
   *
   * Args:
   *     step_id: ID of the step.
   *     step_model: Step model to use for the update.
   *
   * Returns:
   *     The updated step model.
   */
  update_step_api_v1_steps__step_id__put: {
    parameters: {
      path: {
        step_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["StepRunUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["StepRunResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Step Configuration
   * @description Get the configuration of a specific step.
   *
   * Args:
   *     step_id: ID of the step to get.
   *
   * Returns:
   *     The step configuration.
   */
  get_step_configuration_api_v1_steps__step_id__step_configuration_get: {
    parameters: {
      path: {
        step_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Step Status
   * @description Get the status of a specific step.
   *
   * Args:
   *     step_id: ID of the step for which to get the status.
   *
   * Returns:
   *     The status of the step.
   */
  get_step_status_api_v1_steps__step_id__status_get: {
    parameters: {
      path: {
        step_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ExecutionStatus"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Step Logs
   * @description Get the logs of a specific step.
   *
   * Args:
   *     step_id: ID of the step for which to get the logs.
   *
   * Returns:
   *     The logs of the step.
   *
   * Raises:
   *     HTTPException: If no logs are available for this step.
   */
  get_step_logs_api_v1_steps__step_id__logs_get: {
    parameters: {
      path: {
        step_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Artifacts
   * @description Get artifacts according to query filters.
   *
   * Args:
   *     artifact_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The artifacts according to query filters.
   */
  list_artifacts_api_v1_artifacts_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        name?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_ArtifactResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Artifact
   * @description Create a new artifact.
   *
   * Args:
   *     artifact: The artifact to create.
   *
   * Returns:
   *     The created artifact.
   */
  create_artifact_api_v1_artifacts_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArtifactRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ArtifactResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Artifact
   * @description Get an artifact by ID.
   *
   * Args:
   *     artifact_id: The ID of the artifact to get.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The artifact with the given ID.
   */
  get_artifact_api_v1_artifacts__artifact_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        artifact_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ArtifactResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Artifact
   * @description Update an artifact by ID.
   *
   * Args:
   *     artifact_id: The ID of the artifact to update.
   *     artifact_update: The update to apply to the artifact.
   *
   * Returns:
   *     The updated artifact.
   */
  update_artifact_api_v1_artifacts__artifact_id__put: {
    parameters: {
      path: {
        artifact_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArtifactUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ArtifactResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Artifact
   * @description Delete an artifact by ID.
   *
   * Args:
   *     artifact_id: The ID of the artifact to delete.
   */
  delete_artifact_api_v1_artifacts__artifact_id__delete: {
    parameters: {
      path: {
        artifact_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Artifact Versions
   * @description Get artifact versions according to query filters.
   *
   * Args:
   *     artifact_version_filter_model: Filter model used for pagination,
   *         sorting, filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *     auth_context: The authentication context.
   *
   * Returns:
   *     The artifact versions according to query filters.
   */
  list_artifact_versions_api_v1_artifact_versions_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        artifact_id?: string;
        name?: string;
        version?: string;
        version_number?: number | string;
        uri?: string;
        materializer?: string;
        type?: string;
        data_type?: string;
        artifact_store_id?: string;
        workspace_id?: string;
        user_id?: string;
        only_unused?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_ArtifactVersionResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Artifact Version
   * @description Create a new artifact version.
   *
   * Args:
   *     artifact_version: The artifact version to create.
   *
   * Returns:
   *     The created artifact version.
   */
  create_artifact_version_api_v1_artifact_versions_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArtifactVersionRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ArtifactVersionResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Artifact Version
   * @description Get an artifact version by ID.
   *
   * Args:
   *     artifact_version_id: The ID of the artifact version to get.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The artifact version with the given ID.
   */
  get_artifact_version_api_v1_artifact_versions__artifact_version_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        artifact_version_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ArtifactVersionResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Artifact Version
   * @description Update an artifact by ID.
   *
   * Args:
   *     artifact_version_id: The ID of the artifact version to update.
   *     artifact_version_update: The update to apply to the artifact version.
   *
   * Returns:
   *     The updated artifact.
   */
  update_artifact_version_api_v1_artifact_versions__artifact_version_id__put: {
    parameters: {
      path: {
        artifact_version_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArtifactVersionUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ArtifactVersionResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Artifact Version
   * @description Delete an artifact version by ID.
   *
   * Args:
   *     artifact_version_id: The ID of the artifact version to delete.
   */
  delete_artifact_version_api_v1_artifact_versions__artifact_version_id__delete: {
    parameters: {
      path: {
        artifact_version_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Artifact Visualization
   * @description Get the visualization of an artifact.
   *
   * Args:
   *     artifact_version_id: ID of the artifact version for which to get the visualization.
   *     index: Index of the visualization to get (if there are multiple).
   *
   * Returns:
   *     The visualization of the artifact version.
   */
  get_artifact_visualization_api_v1_artifact_versions__artifact_version_id__visualize_get: {
    parameters: {
      query?: {
        index?: number;
      };
      path: {
        artifact_version_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["LoadedVisualization"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Users
   * @description Returns a list of all users.
   *
   * Args:
   *     user_filter_model: Model that takes care of filtering, sorting and
   *         pagination.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     A list of all users.
   */
  list_users_api_v1_users_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        name?: string;
        full_name?: string;
        email?: string;
        active?: boolean | string;
        email_opted_in?: boolean | string;
        external_user_id?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_UserResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create User
   * @description Creates a user.
   *
   * # noqa: DAR401
   *
   * Args:
   *     user: User to create.
   *
   * Returns:
   *     The created user.
   */
  create_user_api_v1_users_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get User
   * @description Returns a specific user.
   *
   * Args:
   *     user_name_or_id: Name or ID of the user.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     A specific user.
   */
  get_user_api_v1_users__user_name_or_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        user_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update User
   * @description Updates a specific user.
   *
   * Args:
   *     user_name_or_id: Name or ID of the user.
   *     user_update: the user to use for the update.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     The updated user.
   */
  update_user_api_v1_users__user_name_or_id__put: {
    parameters: {
      path: {
        user_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete User
   * @description Deletes a specific user.
   *
   * Args:
   *     user_name_or_id: Name or ID of the user.
   *     auth_context: The authentication context.
   *
   * Raises:
   *     IllegalOperationError: If the user is not authorized to delete the user.
   */
  delete_user_api_v1_users__user_name_or_id__delete: {
    parameters: {
      path: {
        user_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Deactivate User
   * @description Deactivates a user and generates a new activation token for it.
   *
   * Args:
   *     user_name_or_id: Name or ID of the user.
   *     auth_context: Authentication context.
   *
   * Returns:
   *     The generated activation token.
   */
  deactivate_user_api_v1_users__user_name_or_id__deactivate_put: {
    parameters: {
      path: {
        user_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Email Opt In Response
   * @description Sets the response of the user to the email prompt.
   *
   * Args:
   *     user_name_or_id: Name or ID of the user.
   *     user_response: User Response to email prompt
   *     auth_context: The authentication context of the user
   *
   * Returns:
   *     The updated user.
   *
   * Raises:
   *     AuthorizationException: if the user does not have the required
   *         permissions
   */
  email_opt_in_response_api_v1_users__user_name_or_id__email_opt_in_put: {
    parameters: {
      path: {
        user_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Current User
   * @description Returns the model of the authenticated user.
   *
   * Args:
   *     auth_context: The authentication context.
   *
   * Returns:
   *     The model of the authenticated user.
   */
  get_current_user_api_v1_current_user_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Myself
   * @description Updates a specific user.
   *
   * Args:
   *     user: the user to use for the update.
   *     auth_context: The authentication context.
   *
   * Returns:
   *     The updated user.
   */
  update_myself_api_v1_current_user_put: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Activate User
   * @description Activates a specific user.
   *
   * Args:
   *     user_name_or_id: Name or ID of the user.
   *     user_update: the user to use for the update.
   *
   * Returns:
   *     The updated user.
   */
  activate_user_api_v1_users__user_name_or_id__activate_put: {
    parameters: {
      path: {
        user_name_or_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Builds
   * @description Gets a list of builds.
   *
   * Args:
   *     build_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     List of build objects.
   */
  list_builds_api_v1_pipeline_builds_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        workspace_id?: string;
        user_id?: string;
        pipeline_id?: string;
        stack_id?: string;
        is_local?: boolean;
        contains_code?: boolean;
        zenml_version?: string;
        python_version?: string;
        checksum?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_PipelineBuildResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Build
   * @description Gets a specific build using its unique id.
   *
   * Args:
   *     build_id: ID of the build to get.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     A specific build object.
   */
  get_build_api_v1_pipeline_builds__build_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        build_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PipelineBuildResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Build
   * @description Deletes a specific build.
   *
   * Args:
   *     build_id: ID of the build to delete.
   */
  delete_build_api_v1_pipeline_builds__build_id__delete: {
    parameters: {
      path: {
        build_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Deployments
   * @description Gets a list of deployment.
   *
   * Args:
   *     deployment_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     List of deployment objects.
   */
  list_deployments_api_v1_pipeline_deployments_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        workspace_id?: string;
        user_id?: string;
        pipeline_id?: string;
        stack_id?: string;
        build_id?: string;
        schedule_id?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_PipelineDeploymentResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Deployment
   * @description Gets a specific deployment using its unique id.
   *
   * Args:
   *     deployment_id: ID of the deployment to get.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     A specific deployment object.
   */
  get_deployment_api_v1_pipeline_deployments__deployment_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        deployment_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PipelineDeploymentResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Deployment
   * @description Deletes a specific deployment.
   *
   * Args:
   *     deployment_id: ID of the deployment to delete.
   */
  delete_deployment_api_v1_pipeline_deployments__deployment_id__delete: {
    parameters: {
      path: {
        deployment_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Code Repositories
   * @description Gets a page of code repositories.
   *
   * Args:
   *     filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     Page of code repository objects.
   */
  list_code_repositories_api_v1_code_repositories_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        workspace_id?: string;
        user_id?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_CodeRepositoryResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Code Repository
   * @description Gets a specific code repository using its unique ID.
   *
   * Args:
   *     code_repository_id: The ID of the code repository to get.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     A specific code repository object.
   */
  get_code_repository_api_v1_code_repositories__code_repository_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        code_repository_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["CodeRepositoryResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Code Repository
   * @description Updates a code repository.
   *
   * Args:
   *     code_repository_id: The ID of the code repository to update.
   *     update: The model containing the attributes to update.
   *
   * Returns:
   *     The updated code repository object.
   */
  update_code_repository_api_v1_code_repositories__code_repository_id__put: {
    parameters: {
      path: {
        code_repository_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CodeRepositoryUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["CodeRepositoryResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Code Repository
   * @description Deletes a specific code repository.
   *
   * Args:
   *     code_repository_id: The ID of the code repository to delete.
   */
  delete_code_repository_api_v1_code_repositories__code_repository_id__delete: {
    parameters: {
      path: {
        code_repository_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Models
   * @description Get models according to query filters.
   *
   * Args:
   *     model_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The models according to query filters.
   */
  list_models_api_v1_models_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        workspace_id?: string;
        user_id?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_ModelResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Model
   * @description Get a model by name or ID.
   *
   * Args:
   *     model_name_or_id: The name or ID of the model to get.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The model with the given name or ID.
   */
  get_model_api_v1_models__model_name_or_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        model_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ModelResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Model
   * @description Delete a model by name or ID.
   *
   * Args:
   *     model_name_or_id: The name or ID of the model to delete.
   */
  delete_model_api_v1_models__model_name_or_id__delete: {
    parameters: {
      path: {
        model_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Model
   * @description Updates a model.
   *
   * Args:
   *     model_id: Name of the stack.
   *     model_update: Stack to use for the update.
   *
   * Returns:
   *     The updated model.
   */
  update_model_api_v1_models__model_id__put: {
    parameters: {
      path: {
        model_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModelUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ModelResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Model Versions
   * @description Get model versions according to query filters.
   *
   * This endpoint serves the purpose of allowing scoped filtering by model_id.
   *
   * Args:
   *     model_name_or_id: The name or ID of the model to list in.
   *     model_version_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *     auth_context: The authentication context.
   *
   * Returns:
   *     The model versions according to query filters.
   */
  list_model_versions_api_v1_models__model_name_or_id__model_versions_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        number?: number;
        workspace_id?: string;
        user_id?: string;
        stage?: string | components["schemas"]["ModelStages"];
      };
      path: {
        model_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_ModelVersionResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Model Versions
   * @description Get model versions according to query filters.
   *
   * Args:
   *     model_version_filter_model: Filter model used for pagination, sorting,
   *         filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *     auth_context: The authentication context.
   *
   * Returns:
   *     The model versions according to query filters.
   */
  list_model_versions_api_v1_model_versions_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        name?: string;
        number?: number;
        workspace_id?: string;
        user_id?: string;
        stage?: string | components["schemas"]["ModelStages"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_ModelVersionResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Model Version
   * @description Get a model version by ID.
   *
   * Args:
   *     model_version_id: id of the model version to be retrieved.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The model version with the given name or ID.
   */
  get_model_version_api_v1_model_versions__model_version_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        model_version_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ModelVersionResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Model Version
   * @description Get all model versions by filter.
   *
   * Args:
   *     model_version_id: The ID of model version to be updated.
   *     model_version_update_model: The model version to be updated.
   *
   * Returns:
   *     An updated model version.
   */
  update_model_version_api_v1_model_versions__model_version_id__put: {
    parameters: {
      path: {
        model_version_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModelVersionUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["ModelVersionResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Model Version
   * @description Delete a model by name or ID.
   *
   * Args:
   *     model_version_id: The name or ID of the model version to delete.
   */
  delete_model_version_api_v1_model_versions__model_version_id__delete: {
    parameters: {
      path: {
        model_version_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Model Version Artifact Link
   * @description Deletes a model version link.
   *
   * Args:
   *     model_version_id: ID of the model version containing the link.
   *     model_version_artifact_link_name_or_id: name or ID of the model
   *         version to artifact link to be deleted.
   */
  delete_model_version_artifact_link_api_v1_model_versions__model_version_id__artifacts__model_version_artifact_link_name_or_id__delete: {
    parameters: {
      path: {
        model_version_id: string;
        model_version_artifact_link_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Model Version Pipeline Run Link
   * @description Deletes a model version link.
   *
   * Args:
   *     model_version_id: name or ID of the model version containing the link.
   *     model_version_pipeline_run_link_name_or_id: name or ID of the model
   *         version link to be deleted.
   */
  delete_model_version_pipeline_run_link_api_v1_model_versions__model_version_id__runs__model_version_pipeline_run_link_name_or_id__delete: {
    parameters: {
      path: {
        model_version_id: string;
        model_version_pipeline_run_link_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Model Version Artifact Links
   * @description Get model version to artifact links according to query filters.
   *
   * Args:
   *     model_version_artifact_link_filter_model: Filter model used for
   *         pagination, sorting, filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The model version to artifact links according to query filters.
   */
  list_model_version_artifact_links_api_v1_model_version_artifacts_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        workspace_id?: string;
        user_id?: string;
        model_id?: string;
        model_version_id?: string;
        artifact_version_id?: string;
        artifact_name?: string;
        only_data_artifacts?: boolean;
        only_model_artifacts?: boolean;
        only_deployment_artifacts?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_ModelVersionArtifactResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Model Version Pipeline Run Links
   * @description Get model version to pipeline run links according to query filters.
   *
   * Args:
   *     model_version_pipeline_run_link_filter_model: Filter model used for
   *         pagination, sorting, and filtering.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The model version to pipeline run links according to query filters.
   */
  list_model_version_pipeline_run_links_api_v1_model_version_pipeline_runs_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        scope_workspace?: string;
        workspace_id?: string;
        user_id?: string;
        model_id?: string;
        model_version_id?: string;
        pipeline_run_id?: string;
        pipeline_run_name?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_ModelVersionPipelineRunResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * List Tags
   * @description Get tags according to query filters.
   *
   * Args:
   *     tag_filter_model: Filter model used for pagination, sorting,
   *         filtering
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The tags according to query filters.
   */
  list_tags_api_v1_tags_get: {
    parameters: {
      query?: {
        hydrate?: boolean;
        sort_by?: string;
        logical_operator?: components["schemas"]["LogicalOperators"];
        page?: number;
        size?: number;
        id?: string;
        created?: string;
        updated?: string;
        name?: string;
        color?: components["schemas"]["ColorVariants"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Page_TagResponse_"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Create Tag
   * @description Create a new tag.
   *
   * Args:
   *     tag: The tag to create.
   *
   * Returns:
   *     The created tag.
   */
  create_tag_api_v1_tags_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TagRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TagResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Conflict */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Get Tag
   * @description Get a tag by name or ID.
   *
   * Args:
   *     tag_name_or_id: The name or ID of the tag to get.
   *     hydrate: Flag deciding whether to hydrate the output model(s)
   *         by including metadata fields in the response.
   *
   * Returns:
   *     The tag with the given name or ID.
   */
  get_tag_api_v1_tags__tag_name_or_id__get: {
    parameters: {
      query?: {
        hydrate?: boolean;
      };
      path: {
        tag_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TagResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Delete Tag
   * @description Delete a tag by name or ID.
   *
   * Args:
   *     tag_name_or_id: The name or ID of the tag to delete.
   */
  delete_tag_api_v1_tags__tag_name_or_id__delete: {
    parameters: {
      path: {
        tag_name_or_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
  /**
   * Update Tag
   * @description Updates a tag.
   *
   * Args:
   *     tag_id: Id or name of the tag.
   *     tag_update_model: Tag to use for the update.
   *
   * Returns:
   *     The updated tag.
   */
  update_tag_api_v1_tags__tag_id__put: {
    parameters: {
      path: {
        tag_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TagUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TagResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
    };
  };
};
