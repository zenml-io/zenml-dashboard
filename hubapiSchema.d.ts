/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export type paths = {
  "/plugins": {
    /**
     * List Plugin Endpoint
     * @description List of all plugin (versions).
     *
     * Args:
     *     offset: Offset for pagination
     *     limit: Limit for pagination
     *     mine: Only show plugins authored by the authenticated user.
     *     user_id: User id of the plugin author
     *     username: Name of the author of the plugin
     *     name: for exactly matching the name of a plugin
     *     name_contains: For optionally filter for all plugins with this string
     *         in the plugin name
     *     db: Async db session
     *     user: Authenticated user
     *     tag: Tag to filter for
     *     starred_by_me: Filter only for plugins starred by the current active
     *         user
     *     status: Filter for only plugins with versions of this status,
     *         attaches the latest version with this status
     *
     * Returns:
     *     List of all plugins within the given filter params.
     */
    get: operations["list_plugin_endpoint_plugins_get"];
    /**
     * Create A Plugin
     * @description Create a plugin along with its first version.
     *
     * Args:
     *     composite_plugin: Composite Plugin create model
     *     db: Async db session
     *     user: Authenticated user
     *
     * Returns:
     *     Read model of the created plugin.
     */
    post: operations["create_a_plugin_plugins_post"];
  };
  "/plugins/{plugin_id}": {
    /**
     * Get A Plugin
     * @description Lets the caller read a plugin with the latest version attached.
     *
     * Args:
     *     plugin_id: ID of the plugin
     *     db: Asynchronous DB session
     *     status: Filter for only plugins with versions of this status,
     *         attaches the latest version with this status
     *
     * Returns:
     *     A read model of the exact plugin version.
     */
    get: operations["get_a_plugin_plugins__plugin_id__get"];
    /**
     * Update A Plugin
     * @description Implements the updating of a specific plugin by the user.
     *
     * Args:
     *     plugin: PluginUpdate model
     *     plugin_id: ID of the plugin to update
     *     db: Asynchronous DB session
     *     user: Authenticated user
     *
     * Returns:
     *     A read model of the updated plugin.
     */
    patch: operations["update_a_plugin_plugins__plugin_id__patch"];
  };
  "/plugins/{plugin_id}/build": {
    /**
     * Build Function Plugin Update
     * @description Endpoint for the build function to update some plugin fields.
     *
     * Args:
     *     plugin_update: PluginVersionUpdate model
     *     plugin_id: ID of the plugin version to update
     *     token: The API Token from the header
     *     db: Asynchronous DB session
     *
     * Returns:
     *     A read model of the updated plugin.
     */
    patch: operations["build_function_plugin_update_plugins__plugin_id__build_patch"];
  };
  "/plugins/{plugin_id}/plugin_versions": {
    /**
     * Create A Plugin Version
     * @description Create a version of a plugin.
     *
     * Args:
     *     plugin_version_create: PluginVersion create model
     *     plugin_id: The ID of the plugin
     *     db: Async db session
     *     user: Authenticated user
     *
     * Returns:
     *     Read model of the created plugin.
     */
    post: operations["create_a_plugin_version_plugins__plugin_id__plugin_versions_post"];
  };
  "/plugin_versions": {
    /**
     * List Plugin Versions Endpoint
     * @description List of all plugin versions.
     *
     * Args:
     *     plugin_id: The id of the Plugin to use for filtering
     *     offset: Offset for pagination
     *     mine: Only show plugins authored by the authenticated user.
     *     limit: Limit for pagination
     *     version: Version of the plugin
     *     user: Authenticated user
     *     status: Filter for plugins with this status.
     *     db: Async db session
     *
     * Returns:
     *     List of all plugins within the given filter params.
     */
    get: operations["list_plugin_versions_endpoint_plugin_versions_get"];
  };
  "/plugin_versions/{version_id}": {
    /**
     * Get A Plugin Version
     * @description Lets the caller read the latest version of a plugin.
     *
     * Args:
     *     version_id: ID of the plugin version
     *     db: Asynchronous DB session
     *
     * Returns:
     *     A read model of the exact plugin version.
     */
    get: operations["get_a_plugin_version_plugin_versions__version_id__get"];
    /**
     * Delete A Plugin
     * @description Delete a plugin version.
     *
     * Args:
     *     version_id: ID of the plugin version to delete
     *     db: DB session to use for deletion.
     *     user: User that performs the deletion
     *
     * Returns:
     *     A return dict (e.G. {"ok": True})
     */
    delete: operations["delete_a_plugin_plugin_versions__version_id__delete"];
    /**
     * Update A Plugin Version
     * @description Implements the updating of a specific plugin by the user.
     *
     * Args:
     *     plugin_version_update: PluginVersionUpdate model
     *     version_id: ID of the plugin version to update
     *     db: Asynchronous DB session
     *     user: Authenticated user
     *
     * Returns:
     *     A read model of the updated plugin.
     */
    patch: operations["update_a_plugin_version_plugin_versions__version_id__patch"];
  };
  "/plugin_versions/{version_id}/build": {
    /**
     * Build Function Plugin Update
     * @description Endpoint for the build function to update the plugin version it just built.
     *
     * Args:
     *     plugin_version_update: PluginVersionUpdate model
     *     version_id: ID of the plugin version to update
     *     token: The API Token from the header
     *     db: Asynchronous DB session
     *
     * Returns:
     *     A read model of the updated plugin.
     */
    patch: operations["build_function_plugin_update_plugin_versions__version_id__build_patch"];
  };
  "/users/me": {
    /** Users:Current User */
    get: operations["users_current_user_users_me_get"];
    /** Users:Patch Current User */
    patch: operations["users_patch_current_user_users_me_patch"];
  };
  "/users/{id}": {
    /** Users:User */
    get: operations["users_user_users__id__get"];
    /** Users:Delete User */
    delete: operations["users_delete_user_users__id__delete"];
    /** Users:Patch User */
    patch: operations["users_patch_user_users__id__patch"];
  };
  "/auth/jwt/login": {
    /** Auth:Jwt.Login */
    post: operations["auth_jwt_login_auth_jwt_login_post"];
  };
  "/auth/jwt/logout": {
    /** Auth:Jwt.Logout */
    post: operations["auth_jwt_logout_auth_jwt_logout_post"];
  };
  "/auth/token/login": {
    /** Auth:Token.Login */
    post: operations["auth_token_login_auth_token_login_post"];
  };
  "/auth/token/logout": {
    /** Auth:Token.Logout */
    post: operations["auth_token_logout_auth_token_logout_post"];
  };
  "/auth/forgot-password": {
    /** Reset:Forgot Password */
    post: operations["reset_forgot_password_auth_forgot_password_post"];
  };
  "/auth/reset-password": {
    /** Reset:Reset Password */
    post: operations["reset_reset_password_auth_reset_password_post"];
  };
  "/auth/request-verify-token": {
    /** Verify:Request-Token */
    post: operations["verify_request_token_auth_request_verify_token_post"];
  };
  "/auth/verify": {
    /** Verify:Verify */
    post: operations["verify_verify_auth_verify_post"];
  };
  "/auth/github/authorize": {
    /**
     * Oauth:Github.Token.Authorize
     * @description Implements the authorize endpoint that returns the Oauth2 login url.
     *
     * Args:
     *     request: The user request
     *     scopes: The scopes of the user
     *
     * Returns:
     *     The Url to start the login flow.
     */
    get: operations["oauth_github_token_authorize_auth_github_authorize_get"];
  };
  "/auth/github/callback": {
    /**
     * Oauth:Github.Token.Callback
     * @description The response varies based on the authentication backend used.
     */
    get: operations["oauth_github_token_callback_auth_github_callback_get"];
  };
  "/interaction": {
    /**
     * List Interactions
     * @description Get a list of all interactions where the filters apply.
     *
     * Args:
     *     user_id: Id of th user that performed the interaction
     *     plugin_id: Id of the plugin the interaction is associated with
     *     interaction_type: Type of interaction (Star, Report ,...)
     *     offset: Offset for pagination
     *     limit: Limit for
     *     mine: Only show interactions performed by the authenticated user.
     *     db: Async db session
     *     user: Authenticated user
     *
     * Returns:
     *     Filtered list of interactions
     */
    get: operations["list_interactions_interaction_get"];
    /**
     * Create An Interaction
     * @description Create an Interaction.
     *
     * Args:
     *     interaction: Interaction create model.
     *     db: Async db session.
     *     user: Authenticated user.
     *
     * Returns:
     *     Read model of the created interaction.
     */
    post: operations["create_an_interaction_interaction_post"];
  };
  "/tag": {
    /**
     * List Tags
     * @description Get a list of all tags where the filters apply.
     *
     * Args:
     *     offset: Offset for pagination
     *     limit: Limit for pagination
     *     name: for exactly matching the name of a plugin
     *     name_contains: For optionally filter for all plugins with this string
     *         in the plugin name
     *     db: Async db session
     *
     * Returns:
     *     Filtered list of tags
     */
    get: operations["list_tags_tag_get"];
    /**
     * Create A Tag
     * @description Create an Interaction.
     *
     * Args:
     *     tag: tag create model.
     *     db: Async db session.
     *     _: Authenticated user.
     *
     * Returns:
     *     Read model of the created interaction.
     */
    post: operations["create_a_tag_tag_post"];
  };
  "/health": {
    /**
     * Health
     * @description Endpoint functioning as health and liveness check.
     */
    get: operations["health_health_get"];
  };
};

export type webhooks = Record<string, never>;

export type components = {
  schemas: {
    /** BearerResponse */
    BearerResponse: {
      /** Access Token */
      access_token: string;
      /** Token Type */
      token_type: string;
    };
    /** Body_auth_jwt_login_auth_jwt_login_post */
    Body_auth_jwt_login_auth_jwt_login_post: {
      /** Grant Type */
      grant_type?: string;
      /** Username */
      username: string;
      /** Password */
      password: string;
      /**
       * Scope
       * @default
       */
      scope?: string;
      /** Client Id */
      client_id?: string;
      /** Client Secret */
      client_secret?: string;
    };
    /** Body_auth_token_login_auth_token_login_post */
    Body_auth_token_login_auth_token_login_post: {
      /** Grant Type */
      grant_type?: string;
      /** Username */
      username: string;
      /** Password */
      password: string;
      /**
       * Scope
       * @default
       */
      scope?: string;
      /** Client Id */
      client_id?: string;
      /** Client Secret */
      client_secret?: string;
    };
    /** Body_reset_forgot_password_auth_forgot_password_post */
    Body_reset_forgot_password_auth_forgot_password_post: {
      /**
       * Email
       * Format: email
       */
      email: string;
    };
    /** Body_reset_reset_password_auth_reset_password_post */
    Body_reset_reset_password_auth_reset_password_post: {
      /** Token */
      token: string;
      /** Password */
      password: string;
    };
    /** Body_verify_request_token_auth_request_verify_token_post */
    Body_verify_request_token_auth_request_verify_token_post: {
      /**
       * Email
       * Format: email
       */
      email: string;
    };
    /** Body_verify_verify_auth_verify_post */
    Body_verify_verify_auth_verify_post: {
      /** Token */
      token: string;
    };
    /**
     * CompositePluginCreate
     * @description Oh God, what have we done, blame this one on Felix!!!
     */
    CompositePluginCreate: {
      /** Version */
      version?: string;
      /** Release Notes */
      release_notes?: string;
      /** Repository Url */
      repository_url: string;
      /** Repository Subdirectory */
      repository_subdirectory?: string;
      /** Repository Branch */
      repository_branch?: string;
      /** Repository Commit */
      repository_commit?: string;
      /** Name */
      name: string;
      /** Description */
      description?: string;
      /** Tags */
      tags?: string[];
      /** Logo Url */
      logo_url?: string;
    };
    /**
     * CompositePluginRead
     * @description Oh God, what have we done, blame this one on Felix!!!
     */
    CompositePluginRead: {
      /** Version */
      version?: string;
      /** Release Notes */
      release_notes?: string;
      /** Repository Url */
      repository_url: string;
      /** Repository Subdirectory */
      repository_subdirectory?: string;
      /** Repository Branch */
      repository_branch?: string;
      /** Repository Commit */
      repository_commit?: string;
      /** Name */
      name: string;
      /** Description */
      description?: string;
      /** Tags */
      tags?: string[];
      /** Logo Url */
      logo_url?: string;
      /**
       * Id
       * Format: uuid
       */
      id: string;
      /**
       * Plugin Id
       * Format: uuid
       */
      plugin_id: string;
      /**
       * Version Id
       * Format: uuid
       */
      version_id: string;
      /** Author */
      author?: string;
      /** Index Url */
      index_url?: string;
      /** Package Name */
      package_name?: string;
      user?: components["schemas"]["UserRead"];
      /** Requirements */
      requirements?: string[];
      /** Build Logs */
      build_logs?: string;
      status: components["schemas"]["PluginStatus"];
      /**
       * Created
       * Format: date-time
       */
      created: string;
      /**
       * Updated
       * Format: date-time
       */
      updated: string;
    };
    /** ErrorModel */
    ErrorModel: {
      /** Detail */
      detail: string | {
        [key: string]: unknown;
      };
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components["schemas"]["ValidationError"][];
    };
    /**
     * InteractionCreate
     * @description Pydantic Model for creation of an Interaction.
     */
    InteractionCreate: {
      type: components["schemas"]["InteractionType"];
      /**
       * Plugin Id
       * Format: uuid
       */
      plugin_id: string;
      /**
       * User Id
       * Format: uuid
       */
      user_id?: string;
      /** Comment */
      comment?: string;
    };
    /**
     * InteractionRead
     * @description Pydantic Model for viewing an Interaction.
     */
    InteractionRead: {
      type: components["schemas"]["InteractionType"];
      /**
       * Plugin Id
       * Format: uuid
       */
      plugin_id: string;
      /**
       * User Id
       * Format: uuid
       */
      user_id?: string;
      /** Comment */
      comment?: string;
      /**
       * Created
       * Format: date-time
       */
      created: string;
    };
    /**
     * InteractionType
     * @description Enum that represents the current status of a step or pipeline run.
     * @enum {string}
     */
    InteractionType: "star" | "report" | "comment";
    /** OAuth2AuthorizeResponse */
    OAuth2AuthorizeResponse: {
      /** Authorization Url */
      authorization_url: string;
    };
    /**
     * PluginBuildUpdate
     * @description Defines all fields that can be updated by the build function.
     */
    PluginBuildUpdate: {
      /** Description */
      description?: string;
      /** Logo Url */
      logo_url?: string;
      /** Tags */
      tags?: string[];
      /** Index Url */
      index_url?: string;
      /** Package Name */
      package_name?: string;
    };
    /**
     * PluginRead
     * @description Pydantic Model for viewing a Plugin (version).
     */
    PluginRead: {
      /** Name */
      name: string;
      /** Description */
      description?: string;
      /** Tags */
      tags?: string[];
      /** Logo Url */
      logo_url?: string;
      /**
       * Id
       * Format: uuid
       */
      id: string;
      /** Index Url */
      index_url?: string;
      /** Package Name */
      package_name?: string;
      /** Author */
      author?: string;
      user?: components["schemas"]["UserRead"];
      /**
       * Created
       * Format: date-time
       */
      created: string;
      /**
       * Updated
       * Format: date-time
       */
      updated: string;
    };
    /**
     * PluginStatus
     * @description Enum that represents the status of a plugin.
     * @enum {string}
     */
    PluginStatus: "pending" | "failed" | "available" | "yanked";
    /**
     * PluginUpdate
     * @description Base class for plugin update models.
     */
    PluginUpdate: {
      /** Description */
      description?: string;
      /** Logo Url */
      logo_url?: string;
      /** Tags */
      tags?: string[];
    };
    /**
     * PluginVersionBuildUpdate
     * @description Defines all fields that can be updated by the build function.
     */
    PluginVersionBuildUpdate: {
      status?: components["schemas"]["PluginStatus"];
      /** Repository Commit */
      repository_commit?: string;
      /** Build Logs */
      build_logs?: string;
      /** Requirements */
      requirements?: string[];
    };
    /**
     * PluginVersionCreate
     * @description Pydantic Model for creation of a Plugin.
     */
    PluginVersionCreate: {
      /** Version */
      version?: string;
      /** Release Notes */
      release_notes?: string;
      /** Repository Url */
      repository_url: string;
      /** Repository Subdirectory */
      repository_subdirectory?: string;
      /** Repository Branch */
      repository_branch?: string;
      /** Repository Commit */
      repository_commit?: string;
    };
    /**
     * PluginVersionRead
     * @description Pydantic Model for viewing a Plugin (version).
     */
    PluginVersionRead: {
      /** Version */
      version: string;
      /** Release Notes */
      release_notes?: string;
      /** Repository Url */
      repository_url: string;
      /** Repository Subdirectory */
      repository_subdirectory?: string;
      /** Repository Branch */
      repository_branch?: string;
      /** Repository Commit */
      repository_commit?: string;
      /**
       * Id
       * Format: uuid
       */
      id: string;
      /**
       * Plugin Id
       * Format: uuid
       */
      plugin_id: string;
      /** Author */
      author: string;
      /** Requirements */
      requirements?: string[];
      /** Build Logs */
      build_logs?: string;
      status: components["schemas"]["PluginStatus"];
      /**
       * Created
       * Format: date-time
       */
      created: string;
      /**
       * Updated
       * Format: date-time
       */
      updated: string;
    };
    /**
     * PluginVersionUserUpdate
     * @description Defines all fields that can be updated by the user.
     */
    PluginVersionUserUpdate: {
      /** Release Notes */
      release_notes?: string;
    };
    /**
     * TagCreate
     * @description Pydantic Model for creation of a tag.
     */
    TagCreate: {
      /** Name */
      name: string;
    };
    /**
     * TagRead
     * @description Pydantic Model for viewing a tag.
     */
    TagRead: {
      /** Name */
      name: string;
    };
    /**
     * UserRead
     * @description User model for displaying user information.
     */
    UserRead: {
      /**
       * Id
       * Format: uuid
       */
      id: string;
      /**
       * Email
       * Format: email
       */
      email: string;
      /**
       * Is Active
       * @default true
       */
      is_active?: boolean;
      /**
       * Is Superuser
       * @default false
       */
      is_superuser?: boolean;
      /**
       * Is Verified
       * @default false
       */
      is_verified?: boolean;
      /** Username */
      username?: string;
      /** Avatar Url */
      avatar_url?: string;
      /** Bio */
      bio?: string;
      /** Website */
      website?: string;
    };
    /**
     * UserUpdate
     * @description User model for performing updates.
     */
    UserUpdate: {
      /** Password */
      password?: string;
      /**
       * Email
       * Format: email
       */
      email?: string;
      /** Is Active */
      is_active?: boolean;
      /** Is Superuser */
      is_superuser?: boolean;
      /** Is Verified */
      is_verified?: boolean;
      /** Avatar Url */
      avatar_url?: string;
      /** Bio */
      bio?: string;
      /** Website */
      website?: string;
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
};

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export type operations = {

  /**
   * List Plugin Endpoint
   * @description List of all plugin (versions).
   *
   * Args:
   *     offset: Offset for pagination
   *     limit: Limit for pagination
   *     mine: Only show plugins authored by the authenticated user.
   *     user_id: User id of the plugin author
   *     username: Name of the author of the plugin
   *     name: for exactly matching the name of a plugin
   *     name_contains: For optionally filter for all plugins with this string
   *         in the plugin name
   *     db: Async db session
   *     user: Authenticated user
   *     tag: Tag to filter for
   *     starred_by_me: Filter only for plugins starred by the current active
   *         user
   *     status: Filter for only plugins with versions of this status,
   *         attaches the latest version with this status
   *
   * Returns:
   *     List of all plugins within the given filter params.
   */
  list_plugin_endpoint_plugins_get: {
    parameters: {
      query?: {
        offset?: number;
        limit?: number;
        mine?: boolean;
        user_id?: string;
        username?: string;
        name_contains?: string;
        name?: string;
        tag?: string;
        starred_by_me?: boolean;
        status?: components["schemas"]["PluginStatus"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["CompositePluginRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create A Plugin
   * @description Create a plugin along with its first version.
   *
   * Args:
   *     composite_plugin: Composite Plugin create model
   *     db: Async db session
   *     user: Authenticated user
   *
   * Returns:
   *     Read model of the created plugin.
   */
  create_a_plugin_plugins_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CompositePluginCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["CompositePluginRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get A Plugin
   * @description Lets the caller read a plugin with the latest version attached.
   *
   * Args:
   *     plugin_id: ID of the plugin
   *     db: Asynchronous DB session
   *     status: Filter for only plugins with versions of this status,
   *         attaches the latest version with this status
   *
   * Returns:
   *     A read model of the exact plugin version.
   */
  get_a_plugin_plugins__plugin_id__get: {
    parameters: {
      query?: {
        status?: components["schemas"]["PluginStatus"];
      };
      path: {
        plugin_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["CompositePluginRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update A Plugin
   * @description Implements the updating of a specific plugin by the user.
   *
   * Args:
   *     plugin: PluginUpdate model
   *     plugin_id: ID of the plugin to update
   *     db: Asynchronous DB session
   *     user: Authenticated user
   *
   * Returns:
   *     A read model of the updated plugin.
   */
  update_a_plugin_plugins__plugin_id__patch: {
    parameters: {
      path: {
        plugin_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PluginUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PluginRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Build Function Plugin Update
   * @description Endpoint for the build function to update some plugin fields.
   *
   * Args:
   *     plugin_update: PluginVersionUpdate model
   *     plugin_id: ID of the plugin version to update
   *     token: The API Token from the header
   *     db: Asynchronous DB session
   *
   * Returns:
   *     A read model of the updated plugin.
   */
  build_function_plugin_update_plugins__plugin_id__build_patch: {
    parameters: {
      path: {
        plugin_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PluginBuildUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PluginRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create A Plugin Version
   * @description Create a version of a plugin.
   *
   * Args:
   *     plugin_version_create: PluginVersion create model
   *     plugin_id: The ID of the plugin
   *     db: Async db session
   *     user: Authenticated user
   *
   * Returns:
   *     Read model of the created plugin.
   */
  create_a_plugin_version_plugins__plugin_id__plugin_versions_post: {
    parameters: {
      path: {
        plugin_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PluginVersionCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PluginVersionRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Plugin Versions Endpoint
   * @description List of all plugin versions.
   *
   * Args:
   *     plugin_id: The id of the Plugin to use for filtering
   *     offset: Offset for pagination
   *     mine: Only show plugins authored by the authenticated user.
   *     limit: Limit for pagination
   *     version: Version of the plugin
   *     user: Authenticated user
   *     status: Filter for plugins with this status.
   *     db: Async db session
   *
   * Returns:
   *     List of all plugins within the given filter params.
   */
  list_plugin_versions_endpoint_plugin_versions_get: {
    parameters: {
      query?: {
        plugin_id?: string;
        offset?: number;
        limit?: number;
        mine?: boolean;
        version?: string;
        status?: components["schemas"]["PluginStatus"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PluginVersionRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get A Plugin Version
   * @description Lets the caller read the latest version of a plugin.
   *
   * Args:
   *     version_id: ID of the plugin version
   *     db: Asynchronous DB session
   *
   * Returns:
   *     A read model of the exact plugin version.
   */
  get_a_plugin_version_plugin_versions__version_id__get: {
    parameters: {
      path: {
        version_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PluginVersionRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Delete A Plugin
   * @description Delete a plugin version.
   *
   * Args:
   *     version_id: ID of the plugin version to delete
   *     db: DB session to use for deletion.
   *     user: User that performs the deletion
   *
   * Returns:
   *     A return dict (e.G. {"ok": True})
   */
  delete_a_plugin_plugin_versions__version_id__delete: {
    parameters: {
      path: {
        version_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Update A Plugin Version
   * @description Implements the updating of a specific plugin by the user.
   *
   * Args:
   *     plugin_version_update: PluginVersionUpdate model
   *     version_id: ID of the plugin version to update
   *     db: Asynchronous DB session
   *     user: Authenticated user
   *
   * Returns:
   *     A read model of the updated plugin.
   */
  update_a_plugin_version_plugin_versions__version_id__patch: {
    parameters: {
      path: {
        version_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PluginVersionUserUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PluginVersionRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Build Function Plugin Update
   * @description Endpoint for the build function to update the plugin version it just built.
   *
   * Args:
   *     plugin_version_update: PluginVersionUpdate model
   *     version_id: ID of the plugin version to update
   *     token: The API Token from the header
   *     db: Asynchronous DB session
   *
   * Returns:
   *     A read model of the updated plugin.
   */
  build_function_plugin_update_plugin_versions__version_id__build_patch: {
    parameters: {
      path: {
        version_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PluginVersionBuildUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PluginVersionRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Users:Current User */
  users_current_user_users_me_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserRead"];
        };
      };
      /** @description Missing token or inactive user. */
      401: {
        content: never;
      };
    };
  };
  /** Users:Patch Current User */
  users_patch_current_user_users_me_patch: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserRead"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Missing token or inactive user. */
      401: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Users:User */
  users_user_users__id__get: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserRead"];
        };
      };
      /** @description Missing token or inactive user. */
      401: {
        content: never;
      };
      /** @description Not a superuser. */
      403: {
        content: never;
      };
      /** @description The user does not exist. */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Users:Delete User */
  users_delete_user_users__id__delete: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    responses: {
      /** @description Successful Response */
      204: {
        content: never;
      };
      /** @description Missing token or inactive user. */
      401: {
        content: never;
      };
      /** @description Not a superuser. */
      403: {
        content: never;
      };
      /** @description The user does not exist. */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Users:Patch User */
  users_patch_user_users__id__patch: {
    parameters: {
      path: {
        id: unknown;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserUpdate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserRead"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Missing token or inactive user. */
      401: {
        content: never;
      };
      /** @description Not a superuser. */
      403: {
        content: never;
      };
      /** @description The user does not exist. */
      404: {
        content: never;
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Auth:Jwt.Login */
  auth_jwt_login_auth_jwt_login_post: {
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["Body_auth_jwt_login_auth_jwt_login_post"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["BearerResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Auth:Jwt.Logout */
  auth_jwt_logout_auth_jwt_logout_post: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Missing token or inactive user. */
      401: {
        content: never;
      };
    };
  };
  /** Auth:Token.Login */
  auth_token_login_auth_token_login_post: {
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["Body_auth_token_login_auth_token_login_post"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["BearerResponse"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Auth:Token.Logout */
  auth_token_logout_auth_token_logout_post: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Missing token or inactive user. */
      401: {
        content: never;
      };
    };
  };
  /** Reset:Forgot Password */
  reset_forgot_password_auth_forgot_password_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["Body_reset_forgot_password_auth_forgot_password_post"];
      };
    };
    responses: {
      /** @description Successful Response */
      202: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Reset:Reset Password */
  reset_reset_password_auth_reset_password_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["Body_reset_reset_password_auth_reset_password_post"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Verify:Request-Token */
  verify_request_token_auth_request_verify_token_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["Body_verify_request_token_auth_request_verify_token_post"];
      };
    };
    responses: {
      /** @description Successful Response */
      202: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Verify:Verify */
  verify_verify_auth_verify_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["Body_verify_verify_auth_verify_post"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["UserRead"];
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Oauth:Github.Token.Authorize
   * @description Implements the authorize endpoint that returns the Oauth2 login url.
   *
   * Args:
   *     request: The user request
   *     scopes: The scopes of the user
   *
   * Returns:
   *     The Url to start the login flow.
   */
  oauth_github_token_authorize_auth_github_authorize_get: {
    parameters: {
      query?: {
        scopes?: string[];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["OAuth2AuthorizeResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Oauth:Github.Token.Callback
   * @description The response varies based on the authentication backend used.
   */
  oauth_github_token_callback_auth_github_callback_get: {
    parameters: {
      query?: {
        code?: string;
        code_verifier?: string;
        state?: string;
        error?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorModel"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Interactions
   * @description Get a list of all interactions where the filters apply.
   *
   * Args:
   *     user_id: Id of th user that performed the interaction
   *     plugin_id: Id of the plugin the interaction is associated with
   *     interaction_type: Type of interaction (Star, Report ,...)
   *     offset: Offset for pagination
   *     limit: Limit for
   *     mine: Only show interactions performed by the authenticated user.
   *     db: Async db session
   *     user: Authenticated user
   *
   * Returns:
   *     Filtered list of interactions
   */
  list_interactions_interaction_get: {
    parameters: {
      query?: {
        user_id?: string;
        plugin_id?: string;
        interaction_type?: components["schemas"]["InteractionType"];
        offset?: number;
        limit?: number;
        mine?: boolean;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["InteractionRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create An Interaction
   * @description Create an Interaction.
   *
   * Args:
   *     interaction: Interaction create model.
   *     db: Async db session.
   *     user: Authenticated user.
   *
   * Returns:
   *     Read model of the created interaction.
   */
  create_an_interaction_interaction_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["InteractionCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["InteractionRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * List Tags
   * @description Get a list of all tags where the filters apply.
   *
   * Args:
   *     offset: Offset for pagination
   *     limit: Limit for pagination
   *     name: for exactly matching the name of a plugin
   *     name_contains: For optionally filter for all plugins with this string
   *         in the plugin name
   *     db: Async db session
   *
   * Returns:
   *     Filtered list of tags
   */
  list_tags_tag_get: {
    parameters: {
      query?: {
        offset?: number;
        limit?: number;
        name?: string;
        name_contains?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TagRead"][];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Create A Tag
   * @description Create an Interaction.
   *
   * Args:
   *     tag: tag create model.
   *     db: Async db session.
   *     _: Authenticated user.
   *
   * Returns:
   *     Read model of the created interaction.
   */
  create_a_tag_tag_post: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TagCreate"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TagRead"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Health
   * @description Endpoint functioning as health and liveness check.
   */
  health_health_get: {
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": {
            [key: string]: unknown;
          };
        };
      };
    };
  };
};
